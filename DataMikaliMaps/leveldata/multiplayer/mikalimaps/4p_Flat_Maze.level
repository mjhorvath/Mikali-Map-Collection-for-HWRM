-- (4P) Flat Maze v1.0.4 by Mikali
-- Created: 2015/03/20
-- Updated: 2020/07/31
-- Homepage: http://isometricland.net/homeworld/homeworld.php
-- Teams: Top vs. Bottom

levelDesc = "<c=FF4800>Flat Maze 1.0.4</c>"
maxPlayers = 4
player = {}

for k = 0, maxPlayers - 1 do
	player[k] = {id = k, name = "", raceName = "Vaygr", resources = 1500, raceID = 2, startPos = 1,}
end

basedm = 8192
levels = 8
modobj = "box_8192_64_8192"

function panelXPos(trans)
	addSquadron("none", modobj, { basedm/2 + trans[1],trans[2],trans[3],}, -1, {000,000,090,}, 1, 0)
end
function panelXNeg(trans)
	addSquadron("none", modobj, {-basedm/2 + trans[1],trans[2],trans[3],}, -1, {000,000,270,}, 1, 0)
end
function panelYPos(trans)
	addSquadron("none", modobj, {trans[1], basedm/2 + trans[2],trans[3],}, -1, {000,000,000,}, 1, 0)
end
function panelYNeg(trans)
	addSquadron("none", modobj, {trans[1],-basedm/2 + trans[2],trans[3],}, -1, {000,180,000,}, 1, 0)
end
function panelZPos(trans)
	addSquadron("none", modobj, {trans[1],trans[2], basedm/2 + trans[3],}, -1, {090,000,000,}, 1, 0)
end
function panelZNeg(trans)
	addSquadron("none", modobj, {trans[1],trans[2],-basedm/2 + trans[3],}, -1, {270,000,000,}, 1, 0)
end

function XOR(num)
	if (mod(num, 2) == 0) then
		return num + 1
	else
		return num - 1
	end
end

-- 3 June 2003, [[:en:User:Cyp]]:
--     Maze, generated by my algorithm
-- 24 October 2006, [[:en:User:quin]]:
--     Source edited for clarity
-- 25 January 2009, [[:en:User:DebateG]]:
--     Source edited again for clarity and reusability
-- 1 June 2009, [[:en:User:Nandhp]]:
--     Source edited to produce SVG file when run from the command-line
-- 7 January, 2011 [[:en:User:SharkD]]:
--     Source converted to JavaScript
-- 8 January, 2011 [[:en:User:SharkD]]:
--     Added third axis to make the maze 3D
--     Added SVG title element
--     Corrected width and height SVG parameters
--     Modified the script so that the padding arounds the side edges is added *after* the maze is generated
--
-- This program was originally written by [[:en:User:Cyp]], who
-- attached it to the image description page for an image generated by
-- it on en.wikipedia. The image was licensed under CC-BY-SA-3.0/GFDL.

-- Construct a Maze with specified lenx, leny, and cell_width
-- The maze generation algorithm.
function createMaze(lenx, leny, lenz, cell_width)
	local dstrings =
	{
		"WALL_ABOVE",
		"WALL_BELOW",
		"WALL_LEFT",
		"WALL_RIGHT",
		"WALL_FRONT",
		"WALL_BACK",
	}
	local maze = {};
	local x, y, z, x_dx, y_dy, z_dz, n, d;
	local dx = { 0, 0, -1, 1, 0, 0 };
	local dy = { -1, 1, 0, 0, 0, 0 };
	local dz = { 0, 0, 0, 0, -1, 1 };

	local todo = {};		--new Array(leny * lenx * lenz);
	local todonum = 1;

	-- We want to create a maze on a grid.
	-- We start with a grid full of walls.
	-- Outer edges are blank and simply used to pad the image.
	for x = 1, lenx do
		maze[x] = {};
		for y = 1, leny do
			maze[x][y] = {};
			for z = 1, lenz do
				-- Define the bit masks
				maze[x][y][z] =
				{
					WALL_ABOVE = 1,
					WALL_BELOW = 1,
					WALL_LEFT = 1,
					WALL_RIGHT = 1,
					WALL_FRONT = 1,
					WALL_BACK = 1,
					QUEUED = 1,
					IN_MAZE = 1,
				}
			end
		end
	end

	-- Select random square of the grid, to start with.
	x = random(1, lenx);
	y = random(1, leny);
	z = random(1, lenz);

	-- Mark this square as connected to the maze.
	maze[x][y][z].QUEUED = 0
	maze[x][y][z].IN_MAZE = 0

 	-- Remember the surrounding squares, as we will...
	for d = 1, 6 do
		x_dx = x + dx[d];
		y_dy = y + dy[d];
		z_dz = z + dz[d];
		if (x_dx > 0 and x_dx <= lenx and y_dy > 0 and y_dy <= leny and z_dz > 0 and z_dz <= lenz) then
			if (maze[x_dx][y_dy][z_dz].QUEUED == 1) then
				-- ...want to connect them to the maze.
				todo[todonum] = {x_dx, y_dy, z_dz};
				maze[x_dx][y_dy][z_dz].QUEUED = 0;
				todonum = todonum + 1
			end
		end
	end

	-- We won't be finished until all is connected.
	while (todonum > 1) do
		-- We select one of the squares next to the maze.
		n = random(1, todonum - 1);
		x = todo[n][1];
		y = todo[n][2];
		z = todo[n][3];

		-- We will connect it, so remove it from the queue.
		todonum = todonum - 1
		todo[n] = todo[todonum];

		-- Select a random direction, which leads to the maze.
		local passBool = 0;
		while (passBool == 0) do
			d = random(1, 6);
			x_dx = x + dx[d];
			y_dy = y + dy[d];
			z_dz = z + dz[d];
			if (x_dx > 0 and x_dx <= lenx and y_dy > 0 and y_dy <= leny and z_dz > 0 and z_dz <= lenz) then
				if (maze[x_dx][y_dy][z_dz].IN_MAZE == 0) then
					passBool = 1;
				end
			end
		end

		-- Connect this square to the maze.
		maze[x][y][z].IN_MAZE = 0
		maze[x][y][z][dstrings[d]] = 0
		maze[x + dx[d]][y + dy[d]][z + dz[d]][dstrings[XOR(d - 1) + 1]] = 0

		-- Remember the surrounding squares, which aren't...
		for d = 1, 6 do
			x_dx = x + dx[d];
			y_dy = y + dy[d];
			z_dz = z + dz[d];
			if (x_dx > 0 and x_dx <= lenx and y_dy > 0 and y_dy <= leny and z_dz > 0 and z_dz <= lenz) then
				if ((maze[x_dx][y_dy][z_dz].QUEUED) == 1) then
					-- ...connected to the maze, and aren't yet queued.
					todo[todonum] = {x_dx, y_dy, z_dz};
					maze[x_dx][y_dy][z_dz].QUEUED = 0;
					todonum = todonum + 1
				end
			end
		end
		-- Repeat until finished.
	end

	-- Add an entrance and exit.
	maze[1][1][1].WALL_LEFT = 0
	maze[1][1][lenz].WALL_BACK = 0
	maze[lenx][1][lenz].WALL_RIGHT = 0
	maze[lenx][1][1].WALL_FRONT = 0

	-- Main maze-drawing loop.
	for x = 1, lenx do
		local rowx = maze[x]
		for y = 1, leny do
			local rowy = rowx[y]
			for z = 1, lenz do
				local rowz = rowy[z]
				local WALL_LEFT  = rowz.WALL_LEFT
				local WALL_RIGHT = rowz.WALL_RIGHT
				local WALL_ABOVE = rowz.WALL_ABOVE
				local WALL_BELOW = rowz.WALL_BELOW
				local WALL_FRONT = rowz.WALL_FRONT
				local WALL_BACK  = rowz.WALL_BACK
				local cell_pos = {cell_width * (x - 1/2 - lenx/2), cell_width * (y - 1/2 - leny/2) + basedm/2, cell_width * (z - 1/2 - lenz/2),}
				if (WALL_LEFT == 1) then
					panelXNeg(cell_pos)
				end
				if (WALL_RIGHT == 1) and (x == lenx) then
					panelXPos(cell_pos)
				end
--				if (WALL_ABOVE == 1) then
--					panelYNeg(cell_pos)
--				end
--				if (WALL_BELOW == 1) and (y == leny) then
--					panelYPos(cell_pos)
--				end
				if (WALL_FRONT == 1) then
					panelZNeg(cell_pos)
				end
				if (WALL_BACK == 1) and (z == lenz) then
					panelZPos(cell_pos)
				end
				if (WALL_LEFT + WALL_RIGHT + WALL_ABOVE + WALL_BELOW + WALL_FRONT + WALL_BACK == 5) then
					addAsteroid("Asteroid_M_5", cell_pos, 100, 0, 0, 0, 0)
				end
			end
		end
	end
end

function DetermChunk()
	addPoint("StartPos0", { basedm * (levels-1)/2, basedm/2, -basedm * (levels-1)/2}, {0,  0, 0})
	addPoint("StartPos1", {-basedm * (levels-1)/2, basedm/2, -basedm * (levels-1)/2}, {0, 90, 0})
	addPoint("StartPos2", {-basedm * (levels-1)/2, basedm/2,  basedm * (levels-1)/2}, {0,180, 0})
	addPoint("StartPos3", { basedm * (levels-1)/2, basedm/2,  basedm * (levels-1)/2}, {0,270, 0})

--	addCamera("pieplatetest", {0,0,0,}, {0, 32768,0,})
--	addCloud("polySurface1", "cloud_text_1", { basedm * (levels-1)/2, basedm/2, -basedm * (levels-1)/2}, {1, 1, 1, 1}, 0, 4096)
--	addCloud("polySurface1", "cloud_text_2", {-basedm * (levels-1)/2, basedm/2, -basedm * (levels-1)/2}, {1, 1, 1, 1}, 0, 4096)
--	addCloud("polySurface1", "cloud_text_3", {-basedm * (levels-1)/2, basedm/2,  basedm * (levels-1)/2}, {1, 1, 1, 1}, 0, 4096)
--	addCloud("polySurface1", "cloud_text_4", { basedm * (levels-1)/2, basedm/2,  basedm * (levels-1)/2}, {1, 1, 1, 1}, 0, 4096)

	createMaze(levels, 1, levels, basedm);

	setWorldBoundsInner({0, basedm/2, 0}, {basedm * (levels/2) * sqrt(2), basedm/2, basedm * (levels/2) * sqrt(2), })
end

function NonDetermChunk()
	fogSetActive(0)
	setGlareIntensity(0.000000)
	setLevelShadowColour(0.000000, 0.000000, 0.000000, 1.0)
	setSensorsManagerCameraDistances(0, 100000)
	local my_seed_1 = {seed = -random(12345)}
	randomBackground(my_seed_1, 1)
	randomMusic(my_seed_1, 1)
	randomBattleMusic(my_seed_1, 1)
end -- end of nondeterm function

dofilepath("data:scripts/MapFunctions.lua")
