-- (6P) Gehenna v1.2.9 by Mikali
-- Created: 2004/02/24
-- Updated: 2015/02/26
-- Homepage: http://isometricland.net
-- Teams: top vs. bottom

levelDesc = "<c=4284A4>Gehenna 1.2.9</c>"
maxPlayers = 6
player = {}

for k = 0, (maxPlayers - 1) do
	player[k] = {id = k, name = "Vaygr", resources = 1500, raceID = 2, startPos = 1,}
end

local    Neb2_O = "Nebula2_OLD"
local   Neb2_O1 = "Nebula2_OLD1"
local   Neb2_O2 = "Nebula2_OLD2"
local   Neb2_O3 = "Nebula2_OLD3"
local   Neb2_O4 = "Nebula2_OLD4"
local   Neb2_O5 = "Nebula2_OLD5"
local   Neb2_O7 = "Nebula2_OLD7"
local    Neb3_O = "Nebula3_OLD"
local   Neb3_O1 = "Nebula3_OLD1"
local   Neb3_O2 = "Nebula3_OLD2"
local   Neb3_O3 = "Nebula3_OLD3"
local   Neb3_O4 = "Nebula3_OLD4"
local    Neb4_O = "Nebula4_OLD"
local   Neb4_O1 = "Nebula4_OLD1"
local    Neb5_O = "Nebula5_OLD"
local    Neb7_O = "Nebula7_OLD"
local    Neb8_O = "Nebula8_OLD"
local     Neb10 = "Nebula10"
local      Peb0 = "Pebble_0"
local      Peb1 = "Pebble_1"
local      Peb2 = "Pebble_2"
local     Poly4 = "polySurface4"
local     Poly5 = "polySurface5"
local     Poly6 = "polySurface6"
local     Poly7 = "polySurface7"
local     Poly8 = "polySurface8"
local     Cld_N = "Cloud_NoRes"
local    Cld_N2 = "Cloud_NoRes2"
local DCld_N_M5 = "DustCloud_NoRes_M05"
local DCld_N2_M5 = "DustCloud_NoRes2_M05"
local DCld_N3_M5 = "DustCloud_NoRes3_M05"

function DetermChunk()
	-- seed value for random functions
	local my_seed = {seed = 977322}

	setWorldBoundsInner({0,0,0,}, {47866.36,27599.16,44018.11,})

	for i, iCount in StartPoints do
		addPoint(iCount[1], iCount[2], iCount[3])
	end
	for i, iCount in EasyPatches do
		easyPatch(iCount[1], 100, my_seed)
	end
	for i, iCount in Squadrons do
		addSquadron(iCount[1], iCount[2], iCount[3], iCount[4], iCount[5], iCount[6], iCount[7])
	end
	for i, iCount in DustClouds do
		addDustCloud(iCount[1], iCount[2], iCount[3], iCount[4], iCount[5], iCount[6])
	end
	for i, iCount in Asteroids do
		addAsteroid(iCount[1], iCount[2], iCount[3], iCount[4], iCount[5], iCount[6], iCount[7])
	end

end

function NonDetermChunk()
	fogSetActive(1)
	fogSetStart(1)
	fogSetEnd(10000)
	fogSetColour(0.332031,0.169922,0.095703,1)
	fogSetType("linear")
	fogSetDensity(0.5)
	setGlareIntensity(0)
	setLevelShadowColour(0,0,0,1)
	loadBackground("m05")
	setSensorsManagerCameraDistances(12000,60000)
	setDustCloudAmbient({0.6,0.6,0.6,1,})
	setNebulaAmbient({0.6,0.6,0.6,1,})

	for i, iCount in Pebbles do
		addPebble(iCount[1], iCount[2], iCount[3], iCount[4], iCount[5])
	end
	for i, iCount in Clouds do
		addCloud(iCount[1], iCount[2], iCount[3], iCount[4], iCount[5], iCount[6])
	end

end

--------------------------------------------------------------------------------

StartPoints =
{
	{"StartPos3", { 03473, 00000, 13700,}, {0,180,0,},},	-- player0
	{"StartPos4", {-02677,-01589, 16261,}, {0,180,0,},},	-- Gehenna 4
	{"StartPos5", { 09960, 00183, 13993,}, {0,180,0,},},	-- Gehenna 5
	{"StartPos0", {-02665, 00014,-14944,}, {0,000,0,},},	-- Gehenna 1, Shipyard
	{"StartPos1", {-11866, 03283,-05335,}, {0,000,0,},},	-- Gehenna 9, Garrison 1
	{"StartPos2", { 21980,-00050,-04893,}, {0,000,0,},},	-- Gehenna 7, Garrison 3
}

EasyPatches =
{
	{{ 01379,-00354, 17029,},},
	{{ 11772,-03076, 03772,},},
	{{-02205, 00000,-18807,},},
	{{-06644,-00509, 19222,},},
	{{ 16228, 00097, 19415,},},

	{{-07702,-01291, 31117,},},
	{{ 03240, 00136, 29821,},},
	{{ 22803,-01291,-21636,},},
	{{-02357,-01291,-37999,},},
	-- Garrison 2
	{{ 10921, 08858,-15044,},},
	{{ 24412, 00000,-07781,},},
	{{-12360, 02358,-02204,},},
	{{-21799, 00593,-20506,},},
	{{ 18288, 00000, 29183,},},
}

Asteroids = {}

Squadrons=
{
	{"Meg_Gehenna_1", "Meg_Gehenna_1", { 00653,-00065,-15086,},-1, {0,0,0,}, 0, 0,},
	{"Meg_Gehenna_2", "Meg_Gehenna_4", { 25792, 00424,-30590,},-1, {0,0,0,}, 0, 0,},
	{"Meg_Gehenna_3", "Meg_Gehenna_6", {-24044, 00368,-25152,},-1, {0,0,0,}, 0, 0,},
	{"Meg_Gehenna_4", "Meg_Gehenna_2", {-06975, 00201, 15142,},-1, {0,0,0,}, 0, 0,},
	{"Meg_Gehenna_5", "Meg_Gehenna_5", { 14686,-01232, 16232,},-1, {0,0,0,}, 0, 0,},
	{"Meg_Gehenna_7", "Meg_Gehenna_7", { 22402,-00401,-08370,},-1, {0,0,0,}, 0, 0,},
	{"Meg_Gehenna_8", "Meg_Gehenna_7", { 11277, 09248,-19058,},-1, {0,0,0,}, 0, 0,},
	{"Meg_Gehenna_9", "Meg_Gehenna_3", {-12418, 03514,-07749,},-1, {0,0,0,}, 0, 0,},
}

DustClouds =
{
	{Neb5_O, DCld_N3_M5, { 08936,-01109, 11983,}, {0.978, 1, 0.978, 0.7092,}, 000.450, 3253.875,},
	{Neb5_O, DCld_N2_M5, {-04782,-00426, 13528,}, {0.978, 1, 0.978, 0.7092,}, 069.590, 4697.800,},
	{Neb5_O, DCld_N2_M5, {-06661, 00000, 12682,}, {0.978, 1, 0.978, 0.7092,}, 210.603, 2946.049,},
	{Neb5_O,  DCld_N_M5, {-08076,-00395, 15235,}, {0.978, 1, 0.978, 0.7092,}, 126.105, 4237.506,},
	-- ship position, Gehenna 4
	{Neb5_O, DCld_N3_M5, {-02677,-01589, 16261,}, {0.978, 1, 0.978, 0.7092,}, 296.222, 6515.978,},
	{Neb5_O, DCld_N3_M5, { 16474,-00124, 14447,}, {0.978, 1, 0.978, 0.7092,}, 062.679, 4791.489,},
	-- asteroid near rock
	{Neb5_O,  DCld_N_M5, {-06644,-00509, 19222,}, {0.978, 1, 0.978, 0.7092,}, 255.781, 5066.952,},
	{Neb5_O, DCld_N3_M5, { 05808,-00352, 11502,}, {0.978, 1, 0.978, 0.7092,}, 109.438, 4267.010,},
	{Neb5_O, DCld_N3_M5, { 10119,-00870, 15817,}, {0.978, 1, 0.978, 0.7092,}, 032.905, 7155.451,},
	{Neb5_O,  DCld_N_M5, { 11877,-00865, 13318,}, {0.978, 1, 0.978, 0.7092,}, 053.033, 4791.489,},
	{Neb5_O,  DCld_N_M5, { 17440,-00073, 15457,}, {0.978, 1, 0.978, 0.7092,}, 355.869, 4142.789,},
	{Neb5_O,  DCld_N_M5, { 02982,-01438, 19488,}, {0.978, 1, 0.978, 0.7092,}, 042.870, 6515.978,},
	{Neb5_O, DCld_N2_M5, { 02588,-00398, 14302,}, {0.978, 1, 0.978, 0.7092,}, 003.208, 4267.010,},
	{Neb5_O, DCld_N3_M5, { 06689,-01062, 16836,}, {0.978, 1, 0.978, 0.7092,}, 191.399, 4574.070,},
	{Neb5_O, DCld_N3_M5, {-00189,-01252, 12987,}, {0.978, 1, 0.978, 0.7092,}, 216.635, 4697.800,},
	-- asteroid near rock
	{Neb5_O,  DCld_N_M5, { 16228, 00097, 19415,}, {0.978, 1, 0.978, 0.7092,}, 059.844, 7155.451,},
	{Neb2_O,  DCld_N_M5, {-07666, 00000, 07067,}, {0.978, 1, 0.978, 0.7092,}, 162.284, 2719.417,},
	{Neb2_O, DCld_N2_M5, {-11540, 03394,-08446,}, {0.978, 1, 0.978, 0.7092,}, 020.534, 3713.043,},
	{Neb2_O, DCld_N2_M5, {-14894, 03555,-05400,}, {0.978, 1, 0.978, 0.7092,}, 281.995, 4250.507,},
	-- asteroid near rock, left
	{Neb2_O,  DCld_N_M5, {-12360, 02358,-02204,}, {0.978, 1, 0.978, 0.7092,}, 187.158, 4250.507,},

	{Neb2_O,  DCld_N_M5, {-06132, 00000, 12565,}, {0.978, 1, 0.978, 0.7092,}, 315.350, 2573.008,},
	{Neb2_O,  DCld_N_M5, {-09952, 00839, 03303,}, {0.978, 1, 0.978, 0.7092,}, 344.124, 2964.774,},
	{Neb2_O, DCld_N3_M5, {-06727, 00000, 09619,}, {0.978, 1, 0.978, 0.7092,}, 194.167, 2901.377,},
	{Neb2_O, DCld_N2_M5, {-07096, 00000, 10180,}, {0.978, 1, 0.978, 0.7092,}, 166.349, 2672.987,},
	{Neb2_O, DCld_N2_M5, {-06222, 00000, 12476,}, {0.978, 1, 0.978, 0.7092,}, 310.406, 2901.377,},
	{Neb2_O, DCld_N3_M5, {-08083, 00191, 07703,}, {0.978, 1, 0.978, 0.7092,}, 280.676, 2672.987,},
	{Neb2_O,  DCld_N_M5, {-08934, 00537, 05533,}, {0.978, 1, 0.978, 0.7092,}, 358.846, 2469.531,},
	{Neb2_O, DCld_N2_M5, {-08631, 00556, 04910,}, {0.978, 1, 0.978, 0.7092,}, 220.140, 2727.290,},
	{Neb2_O,  DCld_N_M5, {-09848, 01091, 02529,}, {0.978, 1, 0.978, 0.7092,}, 095.837, 2824.160,},
	{Neb2_O, DCld_N2_M5, {-11329, 01152, 00696,}, {0.978, 1, 0.978, 0.7092,}, 302.452, 3306.023,},
	{Neb2_O, DCld_N3_M5, {-11173, 01467, 00064,}, {0.978, 1, 0.978, 0.7092,}, 135.312, 3339.042,},

	{Neb2_O,  DCld_N_M5, {-11604, 02649,-03029,}, {0.978, 1, 0.978, 0.7092,}, 243.794, 3375.832,},
	{Neb2_O, DCld_N2_M5, {-09328, 03140,-05474,}, {0.978, 1, 0.978, 0.7092,}, 003.164, 3713.043,},
	{Neb2_O, DCld_N3_M5, {-13361, 04126,-08364,}, {0.978, 1, 0.978, 0.7092,}, 099.319, 3385.295,},

	{Neb4_O, DCld_N2_M5, { 22390, 00011, 04261,}, {0.978, 1, 0.978, 0.7092,}, 211.647, 3328.399,},
	-- asteroid near rock, right possible
	{Neb4_O,  DCld_N_M5, { 22984, 00104,-01122,}, {0.978, 1, 0.978, 0.7092,}, 301.540, 3310.785,},
	{Neb4_O,  DCld_N_M5, { 21678, 00156,-09320,}, {0.978, 1, 0.978, 0.7092,}, 174.578, 3157.698,},
	{Neb4_O, DCld_N3_M5, { 20406,-00007,-04017,}, {0.978, 1, 0.978, 0.7092,}, 267.745, 3162.069,},
	{Neb4_O,  DCld_N_M5, { 22620,-00096,-02261,}, {0.978, 1, 0.978, 0.7092,}, 164.866, 2827.708,},

	{Neb4_O, DCld_N3_M5, { 17433, 00362, 13115,}, {0.978, 1, 0.978, 0.7092,}, 267.998, 2446.494,},
	{Neb4_O, DCld_N3_M5, { 21403, 00366, 05594,}, {0.978, 1, 0.978, 0.7092,}, 215.657, 3277.365,},
	{Neb4_O, DCld_N2_M5, { 17892, 00025, 12695,}, {0.978, 1, 0.978, 0.7092,}, 264.603, 3590.021,},
	{Neb4_O, DCld_N3_M5, { 15966,-00167, 15001,}, {0.978, 1, 0.978, 0.7092,}, 206.066, 2446.494,},
	{Neb4_O, DCld_N3_M5, { 17124, 00016, 13928,}, {0.978, 1, 0.978, 0.7092,}, 054.560, 1588.729,},
	{Neb4_O, DCld_N2_M5, { 18438, 00683, 11142,}, {0.978, 1, 0.978, 0.7092,}, 153.055, 3023.146,},
	{Neb4_O,  DCld_N_M5, { 19933, 00524, 08519,}, {0.978, 1, 0.978, 0.7092,}, 186.158, 3277.365,},
	{Neb4_O, DCld_N2_M5, { 19498, 00007, 09483,}, {0.978, 1, 0.978, 0.7092,}, 270.558, 3590.021,},
	{Neb4_O, DCld_N2_M5, { 20704, 00007, 07130,}, {0.978, 1, 0.978, 0.7092,}, 060.833, 3328.399,},
	{Neb4_O,  DCld_N_M5, { 22409, 00262, 03052,}, {0.978, 1, 0.978, 0.7092,}, 177.083, 2736.376,},
	{Neb4_O, DCld_N3_M5, { 22618, 00100, 00526,}, {0.978, 1, 0.978, 0.7092,}, 251.913, 2794.425,},
	{Neb4_O, DCld_N3_M5, { 22743, 00027, 01770,}, {0.978, 1, 0.978, 0.7092,}, 053.099, 2902.973,},

	{Neb4_O,  DCld_N_M5, { 24645, 00000,-03983,}, {0.978, 1, 0.978, 0.7092,}, 050.967, 3804.292,},
	{Neb4_O,  DCld_N_M5, { 19494, 00000,-07045,}, {0.978, 1, 0.978, 0.7092,}, 249.441, 3162.069,},
	-- asteroid near rock, right
	{Neb4_O, DCld_N3_M5, { 24412, 00000,-07781,}, {0.978, 1, 0.978, 0.7092,}, 153.561, 3804.292,},

	{Neb7_O,  DCld_N_M5, { 09778, 00412, 14555,}, {0.978, 1, 0.978, 0.7092,}, 347.981, 1538.539,},
	{Neb7_O, DCld_N3_M5, { 10263,-00139, 13203,}, {0.978, 1, 0.978, 0.7092,}, 055.164, 2381.230,},
	{Neb7_O, DCld_N2_M5, { 11362,-00937, 11246,}, {0.978, 1, 0.978, 0.7092,}, 295.805, 2381.230,},
	{Neb7_O,  DCld_N_M5, { 11354,-01738, 09280,}, {0.978, 1, 0.978, 0.7092,}, 068.886, 2123.611,},
	{Neb7_O,  DCld_N_M5, { 11565,-01995, 08284,}, {0.978, 1, 0.978, 0.7092,}, 294.190, 1499.939,},
	{Neb7_O,  DCld_N_M5, { 11892,-02105, 06824,}, {0.978, 1, 0.978, 0.7092,}, 055.999, 1786.057,},
	{Neb7_O,  DCld_N_M5, { 11167,-02793, 05344,}, {0.978, 1, 0.978, 0.7092,}, 263.526, 2430.452,},
	{Neb7_O,  DCld_N_M5, { 10556,-03128, 03016,}, {0.978, 1, 0.978, 0.7092,}, 100.649, 2430.452,},
	{Neb7_O, DCld_N3_M5, { 12531,-03101, 03116,}, {0.978, 1, 0.978, 0.7092,}, 245.607, 1977.932,},
	{Neb7_O, DCld_N2_M5, { 12388,-02755, 04982,}, {0.978, 1, 0.978, 0.7092,}, 259.890, 1902.688,},
	{Neb7_O, DCld_N2_M5, { 11888,-02450, 06112,}, {0.978, 1, 0.978, 0.7092,}, 044.287, 1561.222,},
	{Neb7_O, DCld_N2_M5, { 11867,-01888, 07568,}, {0.978, 1, 0.978, 0.7092,}, 300.485, 1561.222,},
	{Neb7_O, DCld_N2_M5, { 11864,-01599, 08826,}, {0.978, 1, 0.978, 0.7092,}, 186.125, 1576.762,},
	{Neb7_O, DCld_N2_M5, { 11413,-01297, 10306,}, {0.978, 1, 0.978, 0.7092,}, 153.440, 1874.883,},
	{Neb7_O, DCld_N3_M5, { 10764,-00653, 11943,}, {0.978, 1, 0.978, 0.7092,}, 341.762, 2355.219,},
	-- ship position, Gehenna 5
	{Neb7_O,  DCld_N_M5, { 09960, 00183, 13993,}, {0.978, 1, 0.978, 0.7092,}, 197.837, 2355.219,},

	{Neb8_O, DCld_N3_M5, { 03674,-01309,-18090,}, {0.978, 1, 0.978, 0.7092,}, 169.821, 4612.148,},
	{Neb8_O,  DCld_N_M5, {-02032,-00681,-19909,}, {0.978, 1, 0.978, 0.7092,}, 304.913, 4630.008,},
	{Neb8_O, DCld_N3_M5, {-04726, 00189,-16246,}, {0.978, 1, 0.978, 0.7092,}, 164.196, 5372.896,},
	{Neb8_O, DCld_N3_M5, {-08825, 01748,-08841,}, {0.978, 1, 0.978, 0.7092,}, 353.869, 4888.434,},
	{Neb8_O,  DCld_N_M5, {-12507, 02989,-05873,}, {0.978, 1, 0.978, 0.7092,}, 266.108, 4888.434,},
	{Neb8_O, DCld_N2_M5, {-10146, 01920,-04905,}, {0.978, 1, 0.978, 0.7092,}, 070.556, 4524.352,},
	{Neb8_O, DCld_N2_M5, {-07849, 01610,-08791,}, {0.978, 1, 0.978, 0.7092,}, 302.199, 4524.352,},
	{Neb8_O, DCld_N3_M5, {-06284, 00743,-11134,}, {0.978, 1, 0.978, 0.7092,}, 180.324, 5372.896,},
	{Neb8_O, DCld_N3_M5, {-05398, 00719,-10934,}, {0.978, 1, 0.978, 0.7092,}, 009.888, 3586.006,},
	{Neb8_O, DCld_N3_M5, {-01939, 00480,-11848,}, {0.978, 1, 0.978, 0.7092,}, 206.132, 4431.481,},
	{Neb8_O, DCld_N3_M5, { 01828,-00581,-13927,}, {0.978, 1, 0.978, 0.7092,}, 191.278, 4612.148,},
	{Neb8_O, DCld_N3_M5, { 00502,-00273,-19988,}, {0.978, 1, 0.978, 0.7092,}, 303.496, 3839.101,},

	{Neb3_O,  DCld_N_M5, { 03276,-00386, 12077,}, {0.978, 1, 0.978, 0.7092,}, 236.741, 2320.053,},
	{Neb3_O,  DCld_N_M5, { 04628, 00738, 04662,}, {0.978, 1, 0.978, 0.7092,}, 303.177, 2640.110,},

	{Neb3_O, DCld_N3_M5, { 13278, 09105,-17711,}, {0.978, 1, 0.978, 0.7092,}, 039.574, 2714.988,},
	{Neb3_O, DCld_N3_M5, { 10637, 09104,-17613,}, {0.978, 1, 0.978, 0.7092,}, 113.064, 2804.596,},
	{Neb3_O, DCld_N2_M5, { 07540, 09097,-16352,}, {0.978, 1, 0.978, 0.7092,}, 102.989, 3958.143,},
	{Neb3_O,  DCld_N_M5, { 08813, 08112,-12735,}, {0.978, 1, 0.978, 0.7092,}, 050.495, 3958.143,},
	{Neb3_O,  DCld_N_M5, { 05655, 04527,-01683,}, {0.978, 1, 0.978, 0.7092,}, 300.463, 3790.389,},

	{Neb3_O, DCld_N2_M5, { 03755, 00267, 08288,}, {0.978, 1, 0.978, 0.7092,}, 216.086, 2956.973,},
	{Neb3_O,  DCld_N_M5, { 04955, 03216, 01804,}, {0.978, 1, 0.978, 0.7092,}, 090.981, 3790.389,},
	{Neb3_O, DCld_N2_M5, { 03652,-00468, 09789,}, {0.978, 1, 0.978, 0.7092,}, 000.582, 3348.146,},
	{Neb3_O, DCld_N3_M5, { 03316,-00287, 11160,}, {0.978, 1, 0.978, 0.7092,}, 290.246, 2956.973,},
	{Neb3_O, DCld_N3_M5, { 04242, 00530, 06648,}, {0.978, 1, 0.978, 0.7092,}, 075.808, 3348.146,},
	{Neb3_O, DCld_N3_M5, { 04171, 01909, 05961,}, {0.978, 1, 0.978, 0.7092,}, 199.155, 2878.307,},
	{Neb3_O, DCld_N2_M5, { 04679, 02537, 03615,}, {0.978, 1, 0.978, 0.7092,}, 040.958, 2481.506,},
	{Neb3_O, DCld_N2_M5, { 05024, 02197, 02497,}, {0.978, 1, 0.978, 0.7092,}, 270.799, 2640.110,},
	{Neb3_O,  DCld_N_M5, { 05285, 02388, 01075,}, {0.978, 1, 0.978, 0.7092,}, 195.640, 2009.003,},

	{Neb3_O, DCld_N3_M5, { 05518, 03266,-00717,}, {0.978, 1, 0.978, 0.7092,}, 157.219, 4051.063,},
	{Neb3_O, DCld_N2_M5, { 06115, 05097,-03969,}, {0.978, 1, 0.978, 0.7092,}, 250.639, 2511.871,},
	{Neb3_O, DCld_N3_M5, { 06547, 05704,-06368,}, {0.978, 1, 0.978, 0.7092,}, 157.208, 2511.871,},
	{Neb3_O,  DCld_N_M5, { 06896, 06121,-08173,}, {0.978, 1, 0.978, 0.7092,}, 208.032, 4051.064,},
	{Neb3_O, DCld_N3_M5, { 06865, 06368,-07353,}, {0.978, 1, 0.978, 0.7092,}, 226.325, 1628.347,},
	{Neb3_O, DCld_N3_M5, { 07228, 06952,-08829,}, {0.978, 1, 0.978, 0.7092,}, 181.489, 2395.634,},
	{Neb3_O,  DCld_N_M5, { 07912, 07586,-11035,}, {0.978, 1, 0.978, 0.7092,}, 250.474, 2395.634,},
	{Neb3_O, DCld_N2_M5, { 08432, 07257,-11863,}, {0.978, 1, 0.978, 0.7092,}, 068.381, 2303.393,},
	{Neb3_O, DCld_N3_M5, { 09617, 07481,-13826,}, {0.978, 1, 0.978, 0.7092,}, 064.206, 3780.054,},
	{Neb3_O, DCld_N3_M5, { 13036, 08499,-15075,}, {0.978, 1, 0.978, 0.7092,}, 164.679, 3780.054,},
	{Neb3_O, DCld_N2_M5, { 08498, 09106,-19427,}, {0.978, 1, 0.978, 0.7092,}, 035.102, 3221.022,},
	{Neb3_O,  DCld_N_M5, { 06207, 04693,-04445,}, {0.978, 1, 0.978, 0.7092,}, 033.982, 4051.064,},
	{Neb3_O,  DCld_N_M5, { 07664, 06689,-10018,}, {0.978, 1, 0.978, 0.7092,}, 335.346, 2077.527,},

	{Neb2_O1, DCld_N3_M5, {-06548,-01291, 28171,}, {0.978, 1, 0.978, 0.7092,}, 254.847, 2719.417,},
	{Neb2_O1, DCld_N2_M5, {-08139,-01291, 33652,}, {0.978, 1, 0.978, 0.7092,}, 078.324, 2573.008,},
	{Neb2_O1, DCld_N3_M5, {-07093,-01291, 30835,}, {0.978, 1, 0.978, 0.7092,}, 060.811, 2901.377,},
	-- asteroid in outskirts, Gehenna 4
	{Neb2_O1, DCld_N3_M5, {-07702,-01291, 31117,}, {0.978, 1, 0.978, 0.7092,}, 122.754, 2672.987,},
	{Neb2_O1, DCld_N3_M5, {-08169,-01291, 33529,}, {0.978, 1, 0.978, 0.7092,}, 132.323, 2901.377,},
	{Neb2_O1,  DCld_N_M5, {-07237,-01100, 28492,}, {0.978, 1, 0.978, 0.7092,}, 288.861, 2672.987,},

	{Neb4_O1, DCld_N3_M5, { 02955, 00491, 25654,}, {0.978, 1, 0.978, 0.7092,}, 189.553, 2442.367,},
	{Neb4_O1, DCld_N3_M5, { 03260, 00495, 34116,}, {0.978, 1, 0.978, 0.7092,}, 287.345, 3257.470,},
	{Neb4_O1,  DCld_N_M5, { 02805, 00154, 26258,}, {0.978, 1, 0.978, 0.7092,}, 052.132, 3590.021,},
	{Neb4_O1,  DCld_N_M5, { 02844,-00038, 23272,}, {0.978, 1, 0.978, 0.7092,}, 144.870, 2442.367,},
	{Neb4_O1, DCld_N3_M5, { 02764, 00145, 24805,}, {0.978, 1, 0.978, 0.7092,}, 049.154, 1546.578,},
	{Neb4_O1, DCld_N3_M5, { 03208, 00812, 27854,}, {0.978, 1, 0.978, 0.7092,}, 023.819, 3023.146,},
	{Neb4_O1, DCld_N3_M5, { 03410, 00653, 30866,}, {0.978, 1, 0.978, 0.7092,}, 206.406, 3257.470,},
	-- asteroid in outskirts, player0
	{Neb4_O1, DCld_N3_M5, { 03240, 00136, 29821,}, {0.978, 1, 0.978, 0.7092,}, 197.299, 3590.021,},
	{Neb4_O1, DCld_N2_M5, { 03237, 00136, 32449,}, {0.978, 1, 0.978, 0.7092,}, 112.086, 2627.953,},
	{Neb2_O2, DCld_N2_M5, { 04097, 00000, 38453,}, {0.978, 1, 0.978, 0.7092,}, 290.894, 1053.346,},
	{Neb2_O2,  DCld_N_M5, { 03902, 00000, 39488,}, {0.978, 1, 0.978, 0.7092,}, 102.330, 1053.346,},
	{Neb2_O2, DCld_N3_M5, { 04384, 00000, 39021,}, {0.978, 1, 0.978, 0.7092,}, 322.283, 0671.314,},

	{Neb2_O3, DCld_N3_M5, { 19469,-01291, 25074,}, {0.978, 1, 0.978, 0.7092,}, 267.767, 2840.289,},
	-- Gehenna 5
	{Neb2_O3, DCld_N3_M5, { 17360,-01291, 23172,}, {0.978, 1, 0.978, 0.7092,}, 130.005, 2840.289,},
	{Neb2_O3, DCld_N2_M5, { 17763,-01291, 25472,}, {0.978, 1, 0.978, 0.7092,}, 082.257, 2334.877,},

	{Neb2_O4, DCld_N3_M5, { 22293,-01291,-18965,}, {0.978, 1, 0.978, 0.7092,}, 082.598, 2719.417,},
	{Neb2_O4, DCld_N3_M5, { 23441,-01291,-24468,}, {0.978, 1, 0.978, 0.7092,}, 195.266, 2537.304,},
	-- asteroid in outskirts, right
	{Neb2_O4, DCld_N2_M5, { 22803,-01291,-21636,}, {0.978, 1, 0.978, 0.7092,}, 019.369, 2790.234,},
	{Neb2_O4, DCld_N3_M5, { 23566,-01291,-21933,}, {0.978, 1, 0.978, 0.7092,}, 188.883, 2665.050,},
	{Neb2_O4, DCld_N3_M5, { 23473,-01291,-24345,}, {0.978, 1, 0.978, 0.7092,}, 034.081, 2790.234,},
	{Neb2_O4, DCld_N2_M5, { 23183,-01100,-19303,}, {0.978, 1, 0.978, 0.7092,}, 320.953, 2665.050,},

	{Neb2_O5, DCld_N2_M5, {-02033, 00000,-32440,}, {0.978, 1, 0.978, 0.7092,}, 052.758, 1053.346,},
	{Neb2_O5,  DCld_N_M5, {-02228, 00000,-31405,}, {0.978, 1, 0.978, 0.7092,}, 335.390, 1053.346,},
	{Neb2_O5, DCld_N2_M5, {-01746, 00000,-31872,}, {0.978, 1, 0.978, 0.7092,}, 016.952, 0671.314,},
	{Neb2_O7, DCld_N3_M5, {-02785,-01291,-35313,}, {0.978, 1, 0.978, 0.7092,}, 121.106, 2719.417,},
	{Neb2_O7,  DCld_N_M5, {-01437,-01291,-40860,}, {0.978, 1, 0.978, 0.7092,}, 143.497, 2573.008,},
	-- asteroid in outskirts, center
	{Neb2_O7,  DCld_N_M5, {-02357,-01291,-37999,}, {0.978, 1, 0.978, 0.7092,}, 340.620, 2901.377,},
	{Neb2_O7, DCld_N3_M5, {-01761,-01291,-38307,}, {0.978, 1, 0.978, 0.7092,}, 192.322, 2638.993,},
	{Neb2_O7, DCld_N3_M5, {-01401,-01291,-40738,}, {0.978, 1, 0.978, 0.7092,}, 249.672, 2901.377,},
	{Neb2_O7, DCld_N2_M5, {-01454,-01100,-35693,}, {0.978, 1, 0.978, 0.7092,}, 093.299, 2638.993,},
}

Pebbles =
{
	{Peb2, { 00929,-00473, 16405,},-62.929,-30.11, 19.079,},
	{Peb2, { 02592, 00600, 15572,},-62.929,-30.11, 19.079,},
	{Peb2, { 02715, 01191, 13750,},-62.929,-30.11, 19.079,},
	{Peb2, { 03118, 01195, 14323,},-62.929,-30.11, 19.079,},
	{Peb2, { 01457,-00613, 17407,},-62.929,-30.11, 19.079,},
	{Peb2, { 03448, 01458, 14381,},-62.929,-30.11, 19.079,},
	{Peb2, { 02040,-00171, 17381,},-62.929,-30.11, 19.079,},
	{Peb2, { 01828, 00657, 16033,},-62.929,-30.11, 19.079,},
	{Peb2, { 02265, 01025, 15619,},-62.929,-30.11, 19.079,},
	{Peb2, { 02105,-00606, 17419,},-62.929,-30.11, 19.079,},
	{Peb2, { 02214, 00431, 16937,},-62.929,-30.11, 19.079,},
	{Peb2, { 02225, 01606, 13837,},-62.929,-30.11, 19.079,},
	{Peb2, { 00847,-00494, 16980,},-62.929,-30.11, 19.079,},
	{Peb2, { 03322, 01830, 14806,},-62.929,-30.11, 19.079,},
	{Peb2, { 00951, 00045, 17791,},-62.929,-30.11, 19.079,},
	{Peb2, { 03345, 01821, 14536,},-62.929,-30.11, 19.079,},
	{Peb2, { 01636, 00577, 15359,},-62.929,-30.11, 19.079,},
	{Peb2, { 00969, 00196, 16333,},-62.929,-30.11, 19.079,},
	{Peb2, { 02288, 01685, 14859,},-62.929,-30.11, 19.079,},
	{Peb2, { 03209, 01322, 14462,},-62.929,-30.11, 19.079,},
	{Peb2, { 01519,-00273, 17268,},-62.929,-30.11, 19.079,},
	{Peb2, { 03319, 02640, 12824,},-62.929,-30.11, 19.079,},
	{Peb2, { 03119, 02315, 12923,},-62.929,-30.11, 19.079,},
	{Peb2, { 02641, 02381, 13025,},-62.929,-30.11, 19.079,},
	{Peb2, { 03183, 02580, 12522,},-62.929,-30.11, 19.079,},

	{Peb2, { 11434,-03683, 02542,},-134.419,-13.397, 36.21,},
	{Peb2, { 11514,-02640, 03569,},-134.419,-13.397, 36.21,},
	{Peb2, { 11749,-03282, 02904,},-134.419,-13.397, 36.21,},
	{Peb2, { 10609,-02689, 03907,},-134.419,-13.397, 36.21,},
	{Peb2, { 12429,-02781, 02966,},-134.419,-13.397, 36.21,},
	{Peb2, { 11731,-03528, 02962,},-134.419,-13.397, 36.21,},
	{Peb2, { 11092,-03067, 03689,},-134.419,-13.397, 36.21,},
	{Peb2, { 11765,-03329, 03365,},-134.419,-13.397, 36.21,},
	{Peb2, { 12110,-02580, 03694,},-134.419,-13.397, 36.21,},
	{Peb2, { 11376,-03085, 03159,},-134.419,-13.397, 36.21,},
	{Peb2, { 12564,-02659, 04056,},-134.419,-13.397, 36.21,},
	{Peb2, { 12516,-03657, 03419,},-134.419,-13.397, 36.21,},
	{Peb2, { 12530,-03252, 02915,},-134.419,-13.397, 36.21,},
	{Peb2, { 10524,-04204, 02866,},-134.419,-13.397, 36.21,},
	{Peb2, { 10429,-02937, 04525,},-134.419,-13.397, 36.21,},
	{Peb2, { 12338,-03783, 02815,},-134.419,-13.397, 36.21,},

	{Peb0, { 19511,-00054, 31346,}, 0, 0, 0,},
	{Peb0, { 18042,-00642, 29789,}, 0, 0, 0,},
	{Peb0, { 17548, 01255, 26706,}, 0, 0, 0,},
	{Peb0, { 19148, 00025, 30371,}, 0, 0, 0,},
	{Peb0, { 17295, 01358, 12559,}, 0, 0, 0,},
	{Peb0, { 18905, 00763, 27410,}, 0, 0, 0,},
	{Peb0, { 18584,-01338, 10655,}, 0, 0, 0,},
	{Peb0, { 16887,-00511, 26383,}, 0, 0, 0,},
	{Peb0, { 17803,-00906, 15316,}, 0, 0, 0,},
	{Peb0, { 16789,-00722, 14747,}, 0, 0, 0,},
	{Peb0, { 17328,-01262, 16316,}, 0, 0, 0,},
	{Peb0, { 17923, 00926, 22225,}, 0, 0, 0,},
	{Peb0, { 17178, 00077, 12836,}, 0, 0, 0,},
	{Peb0, { 17571,-00098, 30121,}, 0, 0, 0,},
	{Peb0, { 16104, 00713, 21595,}, 0, 0, 0,},
	{Peb0, { 17853, 01422, 12845,}, 0, 0, 0,},
	{Peb0, { 17444,-01139, 28016,}, 0, 0, 0,},
	{Peb0, { 17943,-01016, 12170,}, 0, 0, 0,},
	{Peb0, { 19080,-00763, 31461,}, 0, 0, 0,},
	{Peb0, { 18044, 00616, 21396,}, 0, 0, 0,},
	{Peb0, { 16248, 00374, 20161,}, 0, 0, 0,},
	{Peb0, { 17314,-00976, 27588,}, 0, 0, 0,},
	{Peb0, { 16955, 00187, 21471,}, 0, 0, 0,},
	{Peb0, { 18728, 01190, 11715,}, 0, 0, 0,},
	{Peb0, { 16838, 00542, 11636,}, 0, 0, 0,},
	{Peb0, { 17067,-00590, 21933,}, 0, 0, 0,},
	{Peb0, { 15589, 00259, 18281,}, 0, 0, 0,},
	{Peb0, { 16354, 00528, 25193,}, 0, 0, 0,},
	{Peb0, { 16628, 00960, 24468,}, 0, 0, 0,},
	{Peb0, { 17125,-01239, 15219,}, 0, 0, 0,},
	{Peb0, { 17272,-00523, 22501,}, 0, 0, 0,},
	{Peb0, { 17263,-00029, 23372,}, 0, 0, 0,},
	{Peb0, { 16990, 00665, 27108,}, 0, 0, 0,},
	{Peb0, { 19209,-00719, 30178,}, 0, 0, 0,},
	{Peb0, { 16272, 00099, 18749,}, 0, 0, 0,},
	{Peb1, { 16975,-01264, 18805,}, 0, 0, 0,},
	-- mark asteroid in outskirts, back right
	{Peb1, { 18288,-01313, 29183,}, 0, 0, 0,},
	{Peb1, { 16172,-01054, 17528,}, 0, 0, 0,},
	{Peb1, { 17808,-00874, 17275,}, 0, 0, 0,},
	{Peb1, { 16459,-00065, 14616,}, 0, 0, 0,},
	{Peb1, { 17737,-00397, 17853,}, 0, 0, 0,},
	{Peb1, { 16118,-00895, 15257,}, 0, 0, 0,},
	{Peb1, { 19305,-00031, 27470,}, 0, 0, 0,},
	{Peb1, { 18124,-00905, 10250,}, 0, 0, 0,},
	{Peb1, { 17113,-00634, 19653,}, 0, 0, 0,},
	{Peb1, { 16725,-00281, 27289,}, 0, 0, 0,},
	{Peb1, { 16603, 00492, 22664,}, 0, 0, 0,},
	{Peb1, { 20026,-00120, 30487,}, 0, 0, 0,},
	{Peb1, { 18548, 01278, 12052,}, 0, 0, 0,},
	{Peb1, { 18090,-00088, 13491,}, 0, 0, 0,},
	{Peb1, { 17316,-01362, 12797,}, 0, 0, 0,},

	{Peb0, { 20747,-00642, 37779,}, 0, 182.345, 0,},
	{Peb0, { 20548,-00098, 36040,}, 0, 182.345, 0,},
	{Peb0, { 21565,-00976, 39949,}, 0, 182.345, 0,},
	{Peb0, { 21417,-01139, 39526,}, 0, 182.345, 0,},
	{Peb1, { 20526,-01313, 38395,}, 0, 182.345, 0,},
	{Peb0, { 24022,-00976, 44765,}, 0, 182.345, 0,},

	{Peb0, { 56284,-00976, 07276,}, 0, 182.345, 0,},
	{Peb0, { 22929,-01271,-00391,}, 0, 0, 0,},
	{Peb0, { 24100,-00653,-05389,}, 0, 0, 0,},
	{Peb0, { 20384,-01173, 07196,}, 0, 0, 0,},
	{Peb0, { 20730,-01130, 05755,}, 0, 0, 0,},
	{Peb0, { 21492, 00614, 08029,}, 0, 0, 0,},
	{Peb0, { 22292,-00660, 06066,}, 0, 0, 0,},
	{Peb0, { 23534, 01167,-05660,}, 0, 0, 0,},
	{Peb0, { 23035, 00703,-06458,}, 0, 0, 0,},
	{Peb0, { 22745,-00989,-01808,}, 0, 0, 0,},
	{Peb0, { 22977,-01408,-06347,}, 0, 0, 0,},
	{Peb0, { 22963, 00336,-10148,}, 0, 0, 0,},
	{Peb0, { 22585,-00086,-09798,}, 0, 0, 0,},
	{Peb0, { 22093,-00744,-09410,}, 0, 0, 0,},
	{Peb0, { 22018,-00050, 03441,}, 0, 0, 0,},
	{Peb0, { 21369,-00745, 05555,}, 0, 0, 0,},
	{Peb0, { 22698,-00643,-01383,}, 0, 0, 0,},
	{Peb0, { 23594,-00656, 00989,}, 0, 0, 0,},
	{Peb0, { 20746, 00311, 07413,}, 0, 0, 0,},
	{Peb0, { 22279,-00633,-06729,}, 0, 0, 0,},
	{Peb0, { 22502, 01174,-06495,}, 0, 0, 0,},
	{Peb1, { 22382,-00859,-07804,}, 0, 0, 0,},
	{Peb1, { 23112,-01063,-08022,}, 0, 0, 0,},
	{Peb1, { 22037,-00390, 02100,}, 0, 0, 0,},
	{Peb1, { 20550, 00136, 04845,}, 0, 0, 0,},
	{Peb1, { 21812, 00018, 02615,}, 0, 0, 0,},
	{Peb1, { 22581,-01001,-06327,}, 0, 0, 0,},

	{Peb0, { 26970, 00891,-24051,}, 0, 0, 0,},
	{Peb0, { 26149, 02088,-34442,}, 0, 0, 0,},
	{Peb0, { 26464, 00992,-30477,}, 0, 0, 0,},
	{Peb0, { 26620, 00116,-24607,}, 0, 0, 0,},
	{Peb0, { 27078, 01001,-26738,}, 0, 0, 0,},
	{Peb0, { 25893, 00295,-25977,}, 0, 0, 0,},
	{Peb0, { 26584, 01036,-24894,}, 0, 0, 0,},
	{Peb0, { 25907, 00788,-37904,}, 0, 0, 0,},
	{Peb0, { 25262, 00838,-28376,}, 0, 0, 0,},
	{Peb0, { 25435,-00021,-29584,}, 0, 0, 0,},
	{Peb0, { 27304, 00425,-34819,}, 0, 0, 0,},
	{Peb0, { 26237, 02221,-33072,}, 0, 0, 0,},
	{Peb2, { 26691, 00723,-24808,}, 0, 0, 0,},
	{Peb2, { 26379, 01101,-22604,}, 0, 0, 0,},
	{Peb2, { 25605,-00135,-32320,}, 0, 0, 0,},
	{Peb2, { 26277, 02071,-34401,}, 0, 0, 0,},
	{Peb0, { 24807, 01001,-18603,}, 0, 0, 0,},
	{Peb0, { 22999,-00086,-12768,}, 0, 0, 0,},
	{Peb0, { 40107, 00500,-48993,}, 0, 182.345, 0,},
	{Peb0, { 39723, 00420,-50595,}, 0, 182.345, 0,},
	{Peb0, { 40107, 00450,-52388,}, 0, 182.345, 0,},
	{Peb0, { 41527, 00350,-56027,}, 0, 182.345, 0,},

	{Peb0, { 37374, 01684,-11616,}, 0, 0, 0,},
	{Peb0, { 37633, 00597,-11518,}, 0, 0, 0,},
	{Peb0, { 37094, 01119,-12301,}, 0, 0, 0,},
	{Peb0, { 37350, 00903,-14163,}, 0, 0, 0,},
	{Peb0, { 37350, 00903,-10502,}, 0, 0, 0,},

	{Peb0, { 26464,-02330, 09774,}, 0, 0, 0,},
	{Peb0, { 27157,-01389, 08603,}, 0, 0, 0,},
	{Peb0, { 27083,-01855, 09132,}, 0, 0, 0,},
	{Peb0, { 28007,-01855, 10095,}, 0, 0, 0,},

	{Peb2, { 53375,-00351,-32644,}, 0, 0, 0,},
	{Peb0, { 53713,-00358,-33076,}, 0, 206.683, 0,},
	{Peb0, { 53619,-00011,-31283,}, 0, 206.683, 0,},
	{Peb0, { 53447, 00117,-32224,}, 0, 206.683, 0,},

	{Peb0, { 39061,-01389, 23358,}, 0, 0, 0,},
	{Peb0, { 58700,-01389,-14021,}, 0, 0, 0,},
	{Peb0, { 32288, 00587,-54302,}, 0, 0, 0,},

	{Peb0, { 34973, 00483,-63637,}, 0, 0, 0,},
	{Peb0, { 33894, 00294,-65039,}, 0, 0, 0,},
	{Peb0, { 32588,-00757,-58600,}, 0, 0, 0,},
	{Peb0, { 34139, 00147,-63830,}, 0, 0, 0,},
	{Peb0, { 36340, 00951,-71731,}, 0, 0, 0,},
	{Peb0, { 34852, 00433,-71583,}, 0, 0, 0,},
	{Peb2, { 34109,-00463,-63425,}, 0, 0, 0,},
	{Peb2, { 33719, 00205,-66629,}, 0, 0, 0,},

	{Peb0, { 24929, 00500, 56837,}, 0, 182.345, 0,},
	{Peb0, { 24545, 00420, 55236,}, 0, 182.345, 0,},
	{Peb0, { 04138, 00829, 39372,}, 0, 186.707, 0,},
	{Peb0, { 03869,-00259, 39305,}, 0, 186.707, 0,},
	{Peb0, { 04496, 00264, 40020,}, 0, 186.707, 0,},
	{Peb0, { 04458, 00048, 41899,}, 0, 186.707, 0,},
	{Peb0, { 04031, 00048, 38263,}, 0, 186.707, 0,},

	{Peb0, {-16299, 00829, 14692,}, 0, 20.144, 0,},
	{Peb0, {-16022,-00259, 14694,}, 0, 20.144, 0,},
	{Peb0, {-16798, 00264, 14145,}, 0, 20.144, 0,},
	{Peb0, {-17198, 00048, 12309,}, 0, 20.144, 0,},
	{Peb0, {-15937, 00048, 15745,}, 0, 20.144, 0,},

	{Peb0, { 03127,-00473, 10848,}, 0, 0, 0,},
	{Peb0, { 03091, 00124, 09064,}, 0, 0, 0,},
	{Peb0, { 05043, 01863, 04992,}, 0, 0, 0,},
	{Peb0, { 04298, 01235, 06885,}, 0, 0, 0,},
	{Peb0, { 02160,-00265, 16593,}, 0, 0, 0,},
	{Peb0, { 03058,-00512, 27089,}, 0, 0, 0,},
	{Peb0, { 06362, 05112,-02637,}, 0, 0, 0,},
	{Peb0, { 05051, 05006,-02813,}, 0, 0, 0,},
	{Peb0, { 02399,-00962, 23216,}, 0, 0, 0,},
	{Peb0, { 06955, 06432,-04724,}, 0, 0, 0,},
	{Peb0, { 05881, 06445,-05666,}, 0, 0, 0,},
	{Peb0, { 05666, 05466,-04726,}, 0, 0, 0,},
	{Peb0, { 03640, 00265, 19302,}, 0, 0, 0,},
	{Peb0, { 12179, 10358,-22680,}, 0, 0, 0,},
	{Peb0, { 05270, 03800,-01224,}, 0, 0, 0,},
	{Peb0, { 02539,-00844, 16973,}, 0, 0, 0,},
	{Peb0, { 04090, 01477, 04893,}, 0, 0, 0,},
	{Peb0, { 03826,-00084, 29127,}, 0, 0, 0,},
	{Peb0, { 10028, 07785,-16293,}, 0, 0, 0,},
	{Peb0, { 07741, 08518,-13914,}, 0, 0, 0,},
	{Peb0, { 06031, 05798,-05714,}, 0, 0, 0,},
	{Peb0, { 07048, 08196,-10786,}, 0, 0, 0,},
	{Peb0, { 03500, 00493, 14629,}, 0, 0, 0,},
	{Peb0, { 02906, 00825, 24149,}, 0, 0, 0,},
	{Peb0, { 10785, 10208,-19661,}, 0, 0, 0,},
	{Peb0, { 02861,-00464, 18673,}, 0, 0, 0,},
	{Peb0, { 05854, 03319, 01894,}, 0, 0, 0,},
	{Peb0, { 05543, 04245, 01404,}, 0, 0, 0,},
	{Peb0, { 07093, 06527,-07980,}, 0, 0, 0,},
	{Peb0, { 01679,-00108, 25577,}, 0, 0, 0,},
	{Peb0, { 02447, 00120, 22416,}, 0, 0, 0,},
	{Peb0, { 04171,-00222, 14498,}, 0, 0, 0,},
	{Peb0, { 11205, 08439,-20833,}, 0, 0, 0,},
	{Peb0, { 02481,-00390, 29064,}, 0, 0, 0,},
	{Peb0, { 05504, 04973,-02264,}, 0, 0, 0,},
	{Peb0, { 04691, 01575, 04934,}, 0, 0, 0,},
	{Peb0, { 08901, 07702,-14968,}, 0, 0, 0,},
	{Peb0, { 03657, 02467, 03654,}, 0, 0, 0,},
	{Peb0, { 08044, 05919,-08503,}, 0, 0, 0,},
	{Peb0, { 03463, 00821, 30849,}, 0, 0, 0,},
	{Peb0, { 02958, 00826, 25215,}, 0, 0, 0,},
	{Peb0, { 02748,-00427, 32177,}, 0, 0, 0,},
	{Peb0, { 01768, 00487, 24338,}, 0, 0, 0,},
	{Peb0, { 07884, 07581,-08453,}, 0, 0, 0,},
	{Peb0, { 06348, 04057, 00152,}, 0, 0, 0,},
	{Peb0, { 09336, 08831,-14034,}, 0, 0, 0,},
	{Peb0, { 02950, 00086, 16860,}, 0, 0, 0,},
	{Peb0, { 02530, 00552, 23882,}, 0, 0, 0,},
	{Peb0, { 05817, 03554, 01232,}, 0, 0, 0,},
	{Peb0, { 03501, 00209, 07347,}, 0, 0, 0,},
	{Peb0, { 03203,-00218, 31063,}, 0, 0, 0,},
	{Peb0, { 06953, 06917,-10676,}, 0, 0, 0,},
	{Peb0, { 08069, 07064,-12489,}, 0, 0, 0,},
	{Peb0, { 03248, 00577, 12115,}, 0, 0, 0,},
	{Peb0, { 03298,-00102, 22711,}, 0, 0, 0,},
	{Peb0, { 03381, 00453, 14165,}, 0, 0, 0,},
	{Peb2, { 02070,-00734, 21499,}, 0, 0, 0,},
	{Peb2, { 02180, 00623, 19660,}, 0, 0, 0,},
	{Peb2, { 02895, 00611, 08692,}, 0, 0, 0,},
	{Peb2, { 04832, 01165, 05973,}, 0, 0, 0,},
	{Peb2, { 02725, 00018, 24948,}, 0, 0, 0,},
	{Peb2, { 04448, 00243, 07012,}, 0, 0, 0,},
	{Peb2, { 03616, 01507, 05904,}, 0, 0, 0,},
	{Peb2, { 02221, 00284, 19892,}, 0, 0, 0,},
	{Peb2, { 01896,-00507, 25673,}, 0, 0, 0,},
	{Peb2, { 11185, 09738,-20238,}, 0, 0, 0,},
	{Peb2, { 02329,-00941, 22658,}, 0, 0, 0,},
	{Peb2, { 07730, 05729,-07008,}, 0, 0, 0,},
	{Peb2, { 04729, 02827, 02972,}, 0, 0, 0,},
	{Peb2, { 02251,-00237, 21221,}, 0, 0, 0,},
	{Peb2, { 04073,-00401, 14151,}, 0, 0, 0,},
	{Peb2, { 02997, 00268, 16973,}, 0, 0, 0,},
	{Peb2, { 02796,-00804, 20179,}, 0, 0, 0,},
	{Peb2, { 08709, 09344,-13947,}, 0, 0, 0,},
	{Peb2, { 03780, 01595, 08952,}, 0, 0, 0,},
	{Peb2, { 05262, 01086, 05570,}, 0, 0, 0,},
	{Peb2, { 07380, 04729,-03768,}, 0, 0, 0,},
	{Peb2, { 05203, 01891, 05792,}, 0, 0, 0,},

	{Peb2, { 12566, 10671,-31341,}, 0, 164.441, 0,},
	{Peb0, { 12126, 10664,-31014,}, 0, 11.124, 0,},
	{Peb0, { 12696, 11011,-32717,}, 0, 11.124, 0,},
	{Peb0, { 12610, 11139,-31764,}, 0, 11.124, 0,},
	{Peb0, { 11992, 12802,-43769,}, 0, 182.345, 0,},
	{Peb0, { 11607, 12722,-45371,}, 0, 182.345, 0,},
	{Peb0, { 12708, 15074,-55362,}, 0, 182.345, 0,},

	{Peb0, { 05799,-01389, 49145,}, 0, 0, 0,},

	{Peb0, {-07725,-01656, 35352,}, 0, 0, 0,},
	{Peb0, {-08138,-02027, 34740,}, 0, 0, 0,},
	{Peb0, {-06956,-01864, 32559,}, 0, 0, 0,},
	{Peb0, {-07791,-01138, 36037,}, 0, 0, 0,},
	{Peb0, {-07939,-01106, 29050,}, 0, 0, 0,},
	{Peb0, {-08254,-01702, 32710,}, 0, 0, 0,},
	{Peb0, {-08203,-00293, 36034,}, 0, 0, 0,},
	{Peb0, {-07759,-00279, 30051,}, 0, 0, 0,},
	{Peb0, {-08155,-01817, 36281,}, 0, 0, 0,},
	{Peb2, {-06901,-00541, 28386,}, 0, 0, 0,},
	{Peb2, {-06858,-01632, 32905,}, 0, 0, 0,},
	{Peb2, {-07249,-00921, 33392,}, 0, 0, 0,},
	{Peb2, {-07808,-00414, 30244,}, 0, 0, 0,},
	{Peb0, {-06056,-01106, 25575,}, 0, 0, 0,},
	{Peb0, {-05043,-02330, 20731,}, 0, 169.693, 0,},
	{Peb0, {-05935,-01389, 21759,}, 0, 169.693, 0,},
	{Peb0, {-05768,-01855, 21252,}, 0, 169.693, 0,},
	{Peb0, {-06505,-01855, 20139,}, 0, 169.693, 0,},
	{Peb0, {-07730,-00168, 07761,}, 0, 0, 0,},
	{Peb0, {-13151, 02654,-07085,}, 0, 0, 0,},
	{Peb0, {-11453, 03175,-06254,}, 0, 0, 0,},
	{Peb0, {-07576, 00547, 08442,}, 0, 0, 0,},
	{Peb0, {-08483, 01079, 03246,}, 0, 0, 0,},
	{Peb0, {-05397,-00584, 11665,}, 0, 0, 0,},
	{Peb0, {-05978,-01025, 11172,}, 0, 0, 0,},
	{Peb0, {-11360, 02404,-00768,}, 0, 0, 0,},
	{Peb0, {-07465, 00503, 09292,}, 0, 0, 0,},
	{Peb0, {-07052, 00029, 10354,}, 0, 0, 0,},
	{Peb0, {-05314,-00814, 13301,}, 0, 0, 0,},
	{Peb0, {-05976,-00928, 16376,}, 0, 0, 0,},
	{Peb0, {-08732, 01214, 04061,}, 0, 0, 0,},
	{Peb0, {-09235, 01071, 04388,}, 0, 0, 0,},
	{Peb0, {-06319, 01772, 15263,}, 0, 0, 0,},
	{Peb0, {-10438, 00596, 02985,}, 0, 0, 0,},
	{Peb0, {-09441, 00748, 01919,}, 0, 0, 0,},
	{Peb0, {-12172, 01704,-01322,}, 0, 0, 0,},
	{Peb0, {-09073, 01147, 02762,}, 0, 0, 0,},
	{Peb0, {-12040, 01016,-00211,}, 0, 0, 0,},
	{Peb0, {-08001, 00040, 14116,}, 0, 0, 0,},
	{Peb0, {-13202, 04339,-09219,}, 0, 0, 0,},
	{Peb0, {-08851, 00540, 05472,}, 0, 0, 0,},
	{Peb0, {-04933, 00347, 13368,}, 0, 0, 0,},
	{Peb0, {-06801,-00475, 09217,}, 0, 0, 0,},
	{Peb0, {-05005,-00152, 16907,}, 0, 0, 0,},
	{Peb0, {-12934, 02581,-06423,}, 0, 0, 0,},
	{Peb0, {-11576, 02856,-03872,}, 0, 0, 0,},
	{Peb0, {-11855, 04723,-04569,}, 0, 0, 0,},
	{Peb0, {-09529, 01369, 02075,}, 0, 0, 0,},
	{Peb0, {-12411, 02019,-01826,}, 0, 0, 0,},
	{Peb0, {-07213, 00221, 12959,}, 0, 0, 0,},
	{Peb0, {-05823, 01512, 15638,}, 0, 0, 0,},
	{Peb0, {-13091, 04729,-08032,}, 0, 0, 0,},
	{Peb0, {-06150, 00758, 13935,}, 0, 0, 0,},
	{Peb2, {-08358,-00273, 07242,}, 0, 0, 0,},
	{Peb2, {-10060, 02125,-00164,}, 0, 0, 0,},
	{Peb2, {-11232, 00976,-00414,}, 0, 0, 0,},
	{Peb2, {-11497, 03547,-04047,}, 0, 0, 0,},
	{Peb2, {-07463, 00189, 06416,}, 0, 0, 0,},
	{Peb2, {-10906, 01793, 00467,}, 0, 0, 0,},
	{Peb2, {-08217,-00198, 15721,}, 0, 0, 0,},
	{Peb2, {-06329,-00220, 15024,}, 0, 0, 0,},
	{Peb2, {-06496, 01508, 12815,}, 0, 0, 0,},
	{Peb2, {-13696, 02580,-08070,}, 0, 0, 0,},
	{Peb2, {-07344,-00702, 17326,}, 0, 0, 0,},
	{Peb2, {-08724, 00557, 04454,}, 0, 0, 0,},
	{Peb2, {-07056, 00182, 09235,}, 0, 0, 0,},
	{Peb2, {-13242, 03251,-05335,}, 0, 0, 0,},
	{Peb2, {-07279,-00638, 08454,}, 0, 0, 0,},
	{Peb0, {-03212,-00401,-15169,}, 0, 0, 0,},
	{Peb0, {-01082, 01210,-15645,}, 0, 0, 0,},
	{Peb0, {-01340, 01515,-20332,}, 0, 0, 0,},
	{Peb0, {-02652,-00393,-15441,}, 0, 0, 0,},
	{Peb0, {-04301,-00182,-13645,}, 0, 0, 0,},

	{Peb0, { 00039,-00698,-18612,}, 0, 0, 0,},

	{Peb0, {-01419, 01281,-24705,}, 0, 0, 0,},
	{Peb0, {-02645, 00693,-33654,}, 0, 0, 0,},
	{Peb0, {-01247, 01508,-16766,}, 0, 0, 0,},
	{Peb0, {-02154, 00663,-31901,}, 0, 0, 0,},
	{Peb0, {-01498,-00457,-17774,}, 0, 0, 0,},
	{Peb0, {-03481, 00475,-14106,}, 0, 0, 0,},
	{Peb0, {-02658,-00075,-16380,}, 0, 0, 0,},
	{Peb0, {-01308,-00556,-38588,}, 0, 0, 0,},
	{Peb0, {-01647, 00843,-33139,}, 0, 0, 0,},
	{Peb1, {-01199,-01019,-41197,}, 0, 0, 0,},
	{Peb1, {-02193, 00405,-36072,}, 0, 0, 0,},
	{Peb1, {-01441,-01058,-31301,}, 0, 0, 0,},
	{Peb1, {-01290,-00846,-23383,}, 0, 0, 0,},
	{Peb1, {-01814, 00098,-38145,}, 0, 0, 0,},
	{Peb1, {-03364,-00262,-13817,}, 0, 0, 0,},
	{Peb1, {-00845, 00554,-37347,}, 0, 0, 0,},
	{Peb1, {-00291,-01053,-21542,}, 0, 0, 0,},

	{Peb0, {109, 500,-64078,}, 0, 22.287, 0,},

	{Peb0, {-1433, 420,-57478,}, 0, 22.287, 0,},
	{Peb0, {-1182, 450,-55661,}, 0, 22.287, 0,},
	{Peb0, {-1276, 350,-51757,}, 0, 22.287, 0,},

	{Peb2, {39791,-351, 26539,}, 0, 184.858, 0,},
	{Peb0, {39492,-358, 26998,}, 0, 31.541, 0,},
	{Peb0, {39433,-11, 25203,}, 0, 31.541, 0,},
	{Peb0, {39684, 117, 26126,}, 0, 31.541, 0,},

	{Peb2, {-36619, 540,-10950,}, 0, 199.459, 0,},
	{Peb0, {-36349, 532,-9524,}, 0, 46.142, 0,},
	{Peb0, {-37302, 879,-12152,}, 0, 46.142, 0,},
	{Peb0, {-36827, 1008,-11322,}, 0, 46.142, 0,},
	{Peb0, {-38127,-498,-13844,}, 0, 14.601, 0,},

	{Peb0, {-30586,-1478, 24508,}, 0, 21.562, 0,},
	{Peb0, {-29696,-1558, 25894,}, 0, 21.562, 0,},
	{Peb0, {-29469,-1528, 27714,}, 0, 21.562, 0,},

	{Peb0, {-27275,-637, 40906,}, 0, 21.562, 0,},
	{Peb0, {-53075, 450, 6328,}, 0, 21.562, 0,},
	{Peb2, {-21622,-351,-4381,}, 0, 199.459, 0,},
	{Peb2, {-21681, 301,-5662,}, 0, 199.459, 0,},
	{Peb0, {-35658,-487, 9372,}, 0, 21.562, 0,},
	{Peb0, {-17496, 50,-13073,}, 0, 0, 0,},
	{Peb0, {-18465, 585,-17048,}, 0, 0, 0,},
	{Peb0, {-22352, 1118,-25849,}, 0, 0, 0,},
	{Peb0, {-18433,-23,-15176,}, 0, 0, 0,},
	{Peb0, {-30270, 1104,-36895,}, 0, 0, 0,},
	{Peb0, {-19871, 685,-20322,}, 0, 0, 0,},
	{Peb0, {-33204, 1073,-44335,}, 0, 0, 0,},
	{Peb0, {-22231,-454,-21450,}, 0, 0, 0,},
	{Peb0, {-27175,-749,-32878,}, 0, 0, 0,},
	{Peb0, {-28244,-596,-32927,}, 0, 0, 0,},
	{Peb0, {-26685,-1052,-31552,}, 0, 0, 0,},
	{Peb0, {-24325,-802,-25932,}, 0, 0, 0,},
	{Peb0, {-29971, 63,-36214,}, 0, 0, 0,},
	{Peb0, {-17855, 89,-16949,}, 0, 0, 0,},
	{Peb0, {-23378,-615,-27398,}, 0, 0, 0,},
	{Peb0, {-29714, 1158,-36899,}, 0, 0, 0,},
	{Peb0, {-20915,-1023,-19308,}, 0, 0, 0,},
	{Peb0, {-30626,-823,-38573,}, 0, 0, 0,},
	{Peb0, {-17134, 704,-13269,}, 0, 0, 0,},
	{Peb0, {-24873,-531,-26632,}, 0, 0, 0,},
	{Peb0, {-24280,-320,-28529,}, 0, 0, 0,},
	{Peb0, {-21260,-874,-19893,}, 0, 0, 0,},
	{Peb0, {-24054,-161,-27094,}, 0, 0, 0,},
	{Peb0, {-31294, 960,-41075,}, 0, 0, 0,},
	{Peb0, {-31634, 439,-38391,}, 0, 0, 0,},
	{Peb2, {-21990, 510,-24969,}, 0, 0, 0,},
	{Peb2, {-24857,-219,-30268,}, 0, 0, 0,},
	{Peb2, {-23202, 466,-22877,}, 0, 0, 0,},
	{Peb2, {-23238, 842,-23790,}, 0, 0, 0,},
	{Peb2, {-27655,-1025,-32576,}, 0, 0, 0,},
	{Peb2, {-23700, 454,-25989,}, 0, 0, 0,},
	{Peb2, {-23179, 25,-25131,}, 0, 0, 0,},
	-- mark asteroid in outskirts, left
	{Peb2, {-21799, 593,-20506,}, 0, 0, 0,},
	{Peb2, {-18681, 657,-15440,}, 0, 0, 0,},
	{Peb2, {-25073,-84,-29583,}, 0, 0, 0,},
	{Peb2, {-25524, 1071,-29191,}, 0, 0, 0,},
	{Peb2, {-19230, 1191,-17717,}, 0, 0, 0,},
	{Peb2, {-25092, 540,-23829,}, 0, 199.459, 0,},
	{Peb0, {-24407, 532,-22971,}, 0, 46.142, 0,},
	{Peb0, {-26234, 879,-26321,}, 0, 46.142, 0,},
	{Peb0, {-24884, 1008,-24769,}, 0, 46.142, 0,},
	{Peb2, {-22436, 466,-27024,}, 0, 0, 0,},
	{Peb0, {-20512,-454,-24851,}, 0, 0, 0,},
	{Peb0, {-38469,-487,-57231,}, 0, 207.082, 0,},
	{Peb0, {-39488,-567,-58525,}, 0, 207.082, 0,},
	{Peb0, {-39889,-537,-60315,}, 0, 207.082, 0,},
	{Peb0, {-42561,-637,-65152,}, 0, 207.082, 0,},
	{Peb0, {-46697, 450,-44414,}, 0, 21.562, 0,},
	{Peb0, {-9662,-1587, 44372,}, 0, 207.078, 0,},
	{Peb0, {-35964, 4878, 47939,}, 0, 207.078, 0,},
	{Peb0, {-9798,-1112, 46227,}, 0, 207.078, 0,},
	{Peb0, {-10340, 3501, 57457,}, 0, 175.537, 0,},
	{Peb0, {-25314,-615, 40506,}, 0, 0, 0,},
	{Peb0, {-26625,-722, 40330,}, 0, 0, 0,},
	{Peb0, {-24720, 704, 38418,}, 0, 0, 0,},
	{Peb0, {-25795, 717, 37476,}, 0, 0, 0,},
	{Peb0, {-26009,-262, 38417,}, 0, 0, 0,},
	{Peb0, {-26405, 455, 41918,}, 0, 0, 0,},
	{Peb0, {-25645, 71, 37429,}, 0, 0, 0,},
	{Peb0, {-24628, 1477, 32357,}, 0, 0, 0,},
	{Peb0, {-24582, 799, 35162,}, 0, 0, 0,},
	{Peb0, {-26171,-755, 40878,}, 0, 0, 0,},
	{Peb0, {-23631, 191, 34639,}, 0, 0, 0,},
	{Peb0, {-23792, 862, 34689,}, 0, 0, 0,},
	{Peb0, {-25327, 712, 43295,}, 0, 0, 0,},
	{Peb0, {-24723, 199, 32466,}, 0, 0, 0,},
	{Peb2, {-23946, 1, 36134,}, 0, 0, 0,},
	{Peb2, {-24296,-999, 39375,}, 0, 0, 0,},
	{Peb2, {-21152,-9932, 37887,},-134.419,-13.397, 36.21,},
	{Peb0, {-27586,-1868, 48036,}, 0, 0, 0,},
	{Peb0, {-25821,-26, 45037,}, 0, 0, 0,},
	{Peb0, {-26133, 900, 44547,}, 0, 0, 0,},
	{Peb0, {-28019,-878, 46796,}, 0, 0, 0,},
	{Peb0, {-25859, 209, 44375,}, 0, 0, 0,},
	{Peb2, {-26946,-518, 46114,}, 0, 0, 0,},
	{Peb0, {-28627,-850, 54103,}, 0, 0, 0,},
	{Peb0, {-28978,-1138, 54045,}, 0, 0, 0,},
	{Peb2, {-28838,-1548, 55083,}, 0, 0, 0,},
	{Peb2, {-28408,-1628, 54681,}, 0, 0, 0,},
	{Peb2, {-28467,-823, 54903,}, 0, 0, 0,},
	{Peb0, {-28175,-1520, 50489,}, 0, 0, 0,},
	{Peb2, {-28059,-223, 49046,}, 0, 0, 0,},
	{Peb0, {-29372,-1478, 55995,}, 0, 0, 0,},
	{Peb2, {-29222,-2471, 56122,}, 0, 0, 0,},
	{Peb0, {-28585,-1605, 52207,}, 0, 0, 0,},
	{Peb2, {-28780,-1119, 51835,}, 0, 0, 0,},
	{Peb2, {-29889,-1118, 58063,}, 0, 0, 0,},

	{Peb0, {-27275, 5474,-40328,}, 0, 21.562, 0,},
	{Peb0, {-25314, 5495,-40729,}, 0, 0, 0,},
	{Peb0, {-26625, 5389,-40905,}, 0, 0, 0,},
	{Peb0, {-24720, 5558,-42816,}, 0, 0, 0,},
	{Peb0, {-25795, 5570,-43758,}, 0, 0, 0,},
	{Peb0, {-26009, 4591,-42818,}, 0, 0, 0,},
	{Peb0, {-26405, 4183,-39316,}, 0, 0, 0,},
	{Peb0, {-25645, 4924,-43806,}, 0, 0, 0,},
	{Peb0, {-24628, 6255,-48878,}, 0, 0, 0,},
	{Peb0, {-24582, 4972,-46072,}, 0, 0, 0,},
	{Peb0, {-26171, 5356,-40356,}, 0, 0, 0,},
	{Peb0, {-23631, 4364,-46595,}, 0, 0, 0,},
	{Peb0, {-23792, 6026,-46545,}, 0, 0, 0,},
	{Peb0, {-25327, 5198,-37940,}, 0, 0, 0,},
	{Peb0, {-24723, 4977,-48768,}, 0, 0, 0,},
	{Peb2, {-23946, 4854,-45100,}, 0, 0, 0,},
	{Peb2, {-24296, 5112,-41860,}, 0, 0, 0,},
	{Peb0, {-27586, 2618,-33199,}, 0, 0, 0,},
	{Peb0, {-25821, 4460,-36198,}, 0, 0, 0,},
	{Peb0, {-26133, 5386,-36688,}, 0, 0, 0,},
	{Peb0, {-28019, 3608,-34439,}, 0, 0, 0,},
	{Peb0, {-25859, 4695,-36860,}, 0, 0, 0,},
	{Peb2, {-26946, 3968,-35120,}, 0, 0, 0,},
	{Peb0, {-28627,-865,-27132,}, 0, 0, 0,},
	{Peb0, {-28978,-1153,-27190,}, 0, 0, 0,},
	{Peb2, {-28838,-1563,-26151,}, 0, 0, 0,},
	{Peb2, {-28408,-1642,-26554,}, 0, 0, 0,},
	{Peb2, {-28467,-837,-26332,}, 0, 0, 0,},
	{Peb0, {-28175, 1350,-30745,}, 0, 0, 0,},
	{Peb2, {-28059, 2648,-32188,}, 0, 0, 0,},
	{Peb0, {-29372,-1492,-25239,}, 0, 0, 0,},
	{Peb2, {-29222,-2485,-25112,}, 0, 0, 0,},
	{Peb0, {-28585, 1265,-29028,}, 0, 0, 0,},
	{Peb2, {-28780, 1752,-29400,}, 0, 0, 0,},
	{Peb2, {-29889,-1133,-23172,}, 0, 0, 0,},

	{Peb0, {36229,-168, 15337,}, 0, 0, 0,},
	{Peb0, {34779, 547, 17928,}, 0, 0, 0,},
	{Peb0, {35476, 1079, 10822,}, 0, 0, 0,},
	{Peb0, {34294, 2404, 5585,}, 0, 0, 0,},
	{Peb0, {34890, 503, 18778,}, 0, 0, 0,},
	{Peb0, {35303, 29, 19840,}, 0, 0, 0,},
	{Peb0, {35227, 1214, 11637,}, 0, 0, 0,},
	{Peb0, {34724, 1071, 11964,}, 0, 0, 0,},
	{Peb0, {33520, 596, 10561,}, 0, 0, 0,},
	{Peb0, {34517, 748, 9496,}, 0, 0, 0,},
	{Peb0, {33482, 1704, 5031,}, 0, 0, 0,},
	{Peb0, {34885, 1147, 10338,}, 0, 0, 0,},
	{Peb0, {33614, 1016, 7365,}, 0, 0, 0,},
	{Peb0, {35108, 540, 13048,}, 0, 0, 0,},
	{Peb0, {35554,-475, 18703,}, 0, 0, 0,},
	{Peb0, {34430, 1369, 9651,}, 0, 0, 0,},
	{Peb0, {33243, 2019, 4527,}, 0, 0, 0,},
	{Peb2, {35600,-273, 14818,}, 0, 0, 0,},
	{Peb2, {35186, 2125, 7412,}, 0, 0, 0,},
	{Peb2, {34422, 976, 5940,}, 0, 0, 0,},
	{Peb2, {36495, 189, 13992,}, 0, 0, 0,},
	{Peb2, {34339, 1793, 8043,}, 0, 0, 0,},
	{Peb2, {35234, 557, 12030,}, 0, 0, 0,},
	{Peb2, {35299, 182, 18721,}, 0, 0, 0,},
	{Peb2, {35076,-638, 17940,}, 0, 0, 0,},

	{Peb0, {65029, 3094,-77108,}, 0, 21.562, 0,},
	{Peb0, {66989, 1708,-77509,}, 0, 0, 0,},
	{Peb0, {65679, 3009,-77685,}, 0, 0, 0,},
	{Peb0, {67583, 3028,-79596,}, 0, 0, 0,},
	{Peb0, {67721, 3123,-82852,}, 0, 0, 0,},
	{Peb0, {68672, 2515,-83375,}, 0, 0, 0,},
	{Peb0, {68511, 4177,-83325,}, 0, 0, 0,},
	{Peb0, {66976, 653,-74720,}, 0, 0, 0,},
	{Peb2, {68357, 2325,-81880,}, 0, 0, 0,},
	{Peb2, {68007, 1325,-78639,}, 0, 0, 0,},
	{Peb0, {64717, 467,-69979,}, 0, 0, 0,},
	{Peb0, {66482, 1322,-72977,}, 0, 0, 0,},
	{Peb0, {66170, 2248,-73468,}, 0, 0, 0,},
	{Peb0, {64284, 1457,-71218,}, 0, 0, 0,},
	{Peb0, {66444, 1557,-73640,}, 0, 0, 0,},
	{Peb2, {65357, 1817,-71900,}, 0, 0, 0,},
	{Peb0, {63676, 1580,-63912,}, 0, 0, 0,},
	{Peb2, {63466, 883,-62931,}, 0, 0, 0,},
	{Peb0, {64129, 1666,-67525,}, 0, 0, 0,},
	{Peb2, {63082,-40,-61892,}, 0, 0, 0,},

	{Peb0, {-51582, 5426,-33619,}, 0, 21.562, 0,},
	{Peb0, {-49622, 4041,-34020,}, 0, 0, 0,},
	{Peb0, {-50932, 5342,-34196,}, 0, 0, 0,},
	{Peb0, {-49028, 5361,-36107,}, 0, 0, 0,},
	{Peb0, {-48890, 5456,-39363,}, 0, 0, 0,},
	{Peb0, {-47939, 4847,-39886,}, 0, 0, 0,},
	{Peb0, {-48099, 6510,-39836,}, 0, 0, 0,},
	{Peb0, {-49635, 2986,-31231,}, 0, 0, 0,},
	{Peb2, {-48253, 4657,-38391,}, 0, 0, 0,},
	{Peb2, {-48603, 3657,-35151,}, 0, 0, 0,},
	{Peb0, {-51894, 2799,-26490,}, 0, 0, 0,},
	{Peb0, {-50129, 3654,-29489,}, 0, 0, 0,},
	{Peb0, {-50441, 4581,-29979,}, 0, 0, 0,},
	{Peb0, {-52327, 3789,-27730,}, 0, 0, 0,},
	{Peb0, {-50167, 3889,-30151,}, 0, 0, 0,},
	{Peb2, {-51254, 4149,-28411,}, 0, 0, 0,},
	{Peb0, {-52935, 3913,-20423,}, 0, 0, 0,},
	{Peb2, {-53145, 3215,-19442,}, 0, 0, 0,},
	{Peb0, {-52482, 3998,-24036,}, 0, 0, 0,},
	{Peb2, {-53529, 2292,-18403,}, 0, 0, 0,},

	{Peb0, {-14111, 540, 618,}, 0, 0, 0,},
	{Peb2, {-13618,-273, 2388,}, 0, 0, 0,},
	{Peb2, {-15390, 189, 5457,}, 0, 0, 0,},
	{Peb2, {-13984, 557,-400,}, 0, 0, 0,},
}

Clouds =
{
	{Neb10, Cld_N2, {10283, 8914,-24068,}, {1, 1, 1, 0.2,}, 322.063, 10060.29,},
	{Neb10, Cld_N, {18935, 12919,-27280,}, {1, 1, 1, 0.2,}, 81.829, 20473.355,},
	{Neb10, Cld_N, {6460, 6036,-7773,}, {1, 1, 1, 0.2,}, 147.859, 12406.16,},
	{Neb10, Cld_N, {12591, 8897,-18172,}, {1, 1, 1, 0.2,}, 226.106, 12406.16,},
	{Neb10, Cld_N2, {39286, 13797,-25220,}, {1, 1, 1, 0.2,}, 162.581, 20473.355,},
	{Neb10, Cld_N, {50252, 13555,-21836,}, {1, 1, 1, 0.2,}, 215.218, 11479.138,},
	{Neb10, Cld_N2, {44532, 8770,-19963,}, {1, 1, 1, 0.2,}, 307.725, 24207.662,},
	{Neb10, Cld_N, {20788, 10661,-24282,}, {1, 1, 1, 0.2,}, 224.919, 24207.662,},
	{Neb10, Cld_N, {8068, 8488,-16271,}, {1, 1, 1, 0.2,}, 203.671, 8990.22,},
	{Poly4, Cld_N2, {-97361,-40525, 61504,}, {1, 1, 1, 0.2,}, 66.337, 29863.553,},
	{Poly4, Cld_N2, {-81303,-31985, 43347,}, {1, 1, 1, 0.2,}, 199.847, 25699.471,},
	{Poly4, Cld_N2, {-68587,-19694, 32020,}, {1, 1, 1, 0.2,}, 87.432, 21001.672,},
	{Poly4, Cld_N, {-59802,-13952, 23089,}, {1, 1, 1, 0.2,}, 217.701, 15845.865,},
	{Poly4, Cld_N2, {-23701,-4087, 22179,}, {1, 1, 1, 0.2,}, 210.461, 15205.248,},
	{Poly4, Cld_N, {-12095,-2544, 21976,}, {1, 1, 1, 0.2,}, 178.006, 11709.663,},
	{Poly4, Cld_N2, {-7027, 0, 16633,}, {1, 1, 1, 0.2,}, 266.668, 7791.754,},
	{Poly4, Cld_N, {-10288, 0, 19293,}, {1, 1, 1, 0.2,}, 223.337, 13197.41,},
	{Poly4, Cld_N, {-22836,-4087, 19359,}, {1, 1, 1, 0.2,}, 289.63, 15366.822,},
	{Poly4, Cld_N2, {-51974,-7367, 12600,}, {1, 1, 1, 0.2,}, 207.373, 15051.02,},
	{Poly4, Cld_N, {-61348,-11372, 19175,}, {1, 1, 1, 0.2,}, 328.161, 18917.887,},
	{Poly4, Cld_N, {-74481,-20392, 29376,}, {1, 1, 1, 0.2,}, 261.966, 20515.975,},
	{Poly4, Cld_N, {-86314,-35166, 37290,}, {1, 1, 1, 0.2,}, 240.399, 29977.523,},
	{Poly4, Cld_N2, {-103789,-44489, 59792,}, {1, 1, 1, 0.2,}, 113.404, 30442.008,},
	{Poly4, Cld_N2, {-106983,-40296, 89774,}, {1, 1, 1, 0.2,}, 110.097, 30442.008,},
	{Poly4, Cld_N, {-37356,-4228, 14330,}, {1, 1, 1, 0.2,}, 39.08, 15366.822,},
	{Poly4, Cld_N2, {-37664,-6374, 16611,}, {1, 1, 1, 0.2,}, 306.44, 15205.248,},
	{Poly4, Cld_N, {-47400,-7584, 15558,}, {1, 1, 1, 0.2,}, 55.757, 15845.865,},
	{Poly5, Cld_N, {-29581,-4045,-3405,}, {1, 1, 1, 0.2,}, 28.565, 14620.164,},
	{Poly5, Cld_N2, {-18195,-3450, 2730,}, {1, 1, 1, 0.2,}, 230.753, 15449.677,},
	{Poly5, Cld_N, {-10056,-1066, 15643,}, {1, 1, 1, 0.2,}, 196.233, 15449.677,},
	{Poly5, Cld_N2, {-4681, 2078, 14404,}, {1, 1, 1, 0.2,}, 147.232, 17161.473,},
	{Poly5, Cld_N2, {-15724,-3754, 2633,}, {1, 1, 1, 0.2,}, 167.602, 17161.473,},
	{Poly5, Cld_N2, {-26792,-6492,-3731,}, {1, 1, 1, 0.2,}, 54.955, 15418.159,},
	{Poly5, Cld_N2, {-29505,-384,-17625,}, {1, 1, 1, 0.2,}, 265.68, 23391.787,},
	{Poly5, Cld_N, {-13831, 11317,-45094,}, {1, 1, 1, 0.2,}, 297.607, 34876.43,},
	{Poly5, Cld_N2, {-29412,-4199,-18023,}, {1, 1, 1, 0.2,}, 314.405, 34876.43,},
	{Poly5, Cld_N, {-15475, 9710,-33387,}, {1, 1, 1, 0.2,}, 108.021, 23391.787,},
	{Poly6, Cld_N, {17003, 10872,-68086,}, {1, 1, 1, 0.2,}, 45.803, 38224.266,},
	{Poly6, Cld_N2, {-9041, 8296,-49587,}, {1, 1, 1, 0.2,}, 282.588, 32049.111,},
	{Poly6, Cld_N2, {-15229, 13108,-42168,}, {1, 1, 1, 0.2,}, 219.47, 16855.953,},
	{Poly6, Cld_N, {722, 11474,-47365,}, {1, 1, 1, 0.2,}, 26.016, 28242.289,},
	{Poly6, Cld_N2, {23797, 14566,-63353,}, {1, 1, 1, 0.2,}, 235.389, 48734.457,},
	{Poly6, Cld_N2, {41740, 3685,-107338,}, {1, 1, 1, 0.2,}, 37.728, 96640.984,},
	{Poly6, Cld_N, {14032, 88568,-144306,}, {1, 1, 1, 0.2,}, 81.752, 96640.984,},
	{Poly6, Cld_N, {14575, 37629,-143723,}, {1, 1, 1, 0.2,}, 331.193, 50945.719,},
	{Poly6, Cld_N2, {14286, 10624,-106212,}, {1, 1, 1, 0.2,}, 238.608, 46221.004,},
	{Poly7, Cld_N2, {47344, 12346,-21094,}, {1, 1, 1, 0.2,}, 177.314, 50712.961,},
	{Poly7, Cld_N, {54584, 8278,-32024,}, {1, 1, 1, 0.2,}, 178.852, 47967.367,},
	{Poly7, Cld_N2, {90078, 40522,-30856,}, {1, 1, 1, 0.2,}, 183.334, 52221.555,},
	{Poly7, Cld_N2, {134609, 54647,-7520,}, {1, 1, 1, 0.2,}, 247.738, 52221.555,},
	{Poly7, Cld_N2, {144164, 81375, 23474,}, {1, 1, 1, 0.2,}, 218.261, 42027.527,},
	{Poly7, Cld_N2, {113034, 56698, 10170,}, {1, 1, 1, 0.2,}, 2.12, 41892.98,},
	{Poly7, Cld_N, {86349, 40522,-5074,}, {1, 1, 1, 0.2,}, 36.223, 50712.961,},
	{Poly8, Cld_N2, {14096, 0, 15456,}, {1, 1, 1, 0.2,}, 310.769, 4987.229,},
	{Poly8, Cld_N, {18910, 0, 15402,}, {1, 1, 1, 0.2,}, 269.041, 7206.364,},
	{Poly8, Cld_N, {21184, 469, 22223,}, {1, 1, 1, 0.2,}, 136.839, 14416.5,},
	{Poly8, Cld_N2, {23397, 633, 36468,}, {1, 1, 1, 0.2,}, 199.012, 15243.017,},
	{Poly8, Cld_N2, {31398,-1857, 49201,}, {1, 1, 1, 0.2,}, 344.058, 15243.017,},
	{Poly8, Cld_N2, {39179,-3035, 61091,}, {1, 1, 1, 0.2,}, 63.569, 30227.789,},
	{Poly8, Cld_N2, {46188,-7552, 90146,}, {1, 1, 1, 0.2,}, 47.385, 47622.996,},
	{Poly8, Cld_N2, {24275,-26224, 128081,}, {1, 1, 1, 0.2,}, 342.619, 59451.867,},
	{Poly8, Cld_N, {-33081,-31029, 142971,}, {1, 1, 1, 0.2,}, 10.02, 74405.273,},
	{Poly8, Cld_N2, {14655,-7552, 90950,}, {1, 1, 1, 0.2,}, 20.128, 74405.273,},
	{Poly8, Cld_N, {26125,-3035, 67389,}, {1, 1, 1, 0.2,}, 47.385, 26590.6,},
	{Poly8, Cld_N, {16942,-784, 50382,}, {1, 1, 1, 0.2,}, 311.153, 23281.617,},
	{Poly8, Cld_N, {17395, 222, 27127,}, {1, 1, 1, 0.2,}, 259.791, 23281.617,},
	{Poly8, Cld_N, {17782, 0, 18816,}, {1, 1, 1, 0.2,}, 5.285, 8322.739,},
	{Neb3_O1, Cld_N, {-17471, 1057,-14307,}, {1, 1, 1, 0.25,}, 189.212, 3451.156,},
	{Neb3_O1, Cld_N, {-22909,-552,-24045,}, {1, 1, 1, 0.25,}, 143.53, 3583.806,},
	{Neb3_O1, Cld_N, {-27539, 798,-33132,}, {1, 1, 1, 0.25,}, 210.801, 5448.236,},
	{Neb3_O1, Cld_N, {-20403, 359,-19169,}, {1, 1, 1, 0.25,}, 246.244, 4357.947,},
	{Neb3_O1, Cld_N, {-25063, 823,-28279,}, {1, 1, 1, 0.25,}, 156.78, 5448.236,},
	{Neb3_O1, Cld_N2, {-19197, 160,-17158,}, {1, 1, 1, 0.25,}, 2.582, 4857.382,},
	{Neb3_O1, Cld_N, {-18239, 849,-15418,}, {1, 1, 1, 0.25,}, 216.558, 4357.947,},
	{Neb3_O1, Cld_N2, {-21465,-28,-21449,}, {1, 1, 1, 0.25,}, 207.604, 4857.382,},
	{Neb3_O1, Cld_N, {-22061, 1086,-22602,}, {1, 1, 1, 0.25,}, 80.038, 3881.326,},
	{Neb3_O1, Cld_N, {-23710, 818,-25816,}, {1, 1, 1, 0.25,}, 1.538, 3622.568,},
	{Neb3_O1, Cld_N, {-24447, 56,-27223,}, {1, 1, 1, 0.25,}, 29.609, 3583.806,},
	{Neb3_O1, Cld_N2, {-25490,-276,-29085,}, {1, 1, 1, 0.25,}, 307.835, 2828.99,},
	{Neb3_O1, Cld_N, {-26848,-65,-31558,}, {1, 1, 1, 0.25,}, 291.982, 5817.503,},
	{Neb3_O1, Cld_N, {-29174, 505,-36229,}, {1, 1, 1, 0.25,}, 248.936, 3676.681,},
	{Neb3_O1, Cld_N, {-30927, 218,-39448,}, {1, 1, 1, 0.25,}, 190.849, 3676.681,},
	{Neb3_O1, Cld_N2, {-32230,-42,-41874,}, {1, 1, 1, 0.25,}, 51.396, 5817.504,},
	{Neb3_O1, Cld_N, {-31525, 463,-40983,}, {1, 1, 1, 0.25,}, 262.043, 2330.128,},
	{Neb3_O1, Cld_N, {-32522, 465,-43089,}, {1, 1, 1, 0.25,}, 11.184, 3472.819,},
	{Neb3_O1, Cld_N, {-33919, 205,-46258,}, {1, 1, 1, 0.25,}, 232.027, 3472.819,},
	{Neb3_O1, Cld_N2, {-34271,-494,-47449,}, {1, 1, 1, 0.25,}, 30.763, 2977.017,},
	{Neb3_O1, Cld_N, {-29539,-53,-36716,}, {1, 1, 1, 0.25,}, 341.246, 5817.504,},
	{Neb3_O1, Cld_N2, {-33250,-268,-44661,}, {1, 1, 1, 0.25,}, 98.99, 2977.017,},
	{Neb3_O2, Cld_N2, {30494, 719,-46010,}, {1, 1, 1, 0.25,}, 353.441, 3451.156,},
	{Neb3_O2, Cld_N2, {28271,-980,-35094,}, {1, 1, 1, 0.25,}, 105.208, 3583.806,},
	{Neb3_O2, Cld_N, {26349, 312,-25071,}, {1, 1, 1, 0.25,}, 132.312, 5448.236,},
	{Neb3_O2, Cld_N2, {29568,-60,-40419,}, {1, 1, 1, 0.25,}, 78.708, 4357.947,},
	{Neb3_O2, Cld_N, {27501, 357,-30396,}, {1, 1, 1, 0.25,}, 86.597, 5448.236,},
	{Neb3_O2, Cld_N2, {29872,-219,-42747,}, {1, 1, 1, 0.25,}, 324.821, 4857.382,},
	{Neb3_O2, Cld_N, {30349, 477,-44673,}, {1, 1, 1, 0.25,}, 324.953, 4357.947,},
	{Neb3_O2, Cld_N2, {28885,-434,-37996,}, {1, 1, 1, 0.25,}, 28.84, 4857.382,},
	{Neb3_O2, Cld_N, {28809, 657,-36681,}, {1, 1, 1, 0.25,}, 61.844, 3881.326,},
	{Neb3_O2, Cld_N, {28010, 378,-33159,}, {1, 1, 1, 0.25,}, 279.314, 3622.568,},
	{Neb3_O2, Cld_N, {27561,-381,-31633,}, {1, 1, 1, 0.25,}, 75.83, 3583.806,},
	{Neb3_O2, Cld_N, {27134,-730,-29545,}, {1, 1, 1, 0.25,}, 1.351, 2828.99,},
	{Neb3_O2, Cld_N2, {26658,-548,-26762,}, {1, 1, 1, 0.25,}, 41.057, 5817.503,},
	{Neb3_O2, Cld_N2, {25608, 3,-21650,}, {1, 1, 1, 0.25,}, 112.009, 3676.681,},
	{Neb3_O2, Cld_N, {24881,-311,-18059,}, {1, 1, 1, 0.25,}, 13.887, 3676.681,},
	{Neb3_O2, Cld_N, {24312,-587,-15366,}, {1, 1, 1, 0.25,}, 68.139, 5817.504,},
	{Neb3_O2, Cld_N, {24418,-47,-16481,}, {1, 1, 1, 0.25,}, 55.263, 2330.128,},
	{Neb3_O2, Cld_N2, {23862,-41,-14218,}, {1, 1, 1, 0.25,}, 318.734, 3472.819,},
	{Neb3_O2, Cld_N2, {22900,-275,-10890,}, {1, 1, 1, 0.25,}, 70.436, 3472.819,},
	{Neb3_O2, Cld_N, {22843,-927,-9771,}, {1, 1, 1, 0.25,}, 232.401, 2840.808,},
	{Neb3_O2, Cld_N, {25485,-568,-21064,}, {1, 1, 1, 0.25,}, 327.293, 5817.504,},
	{Neb3_O2, Cld_N2, {23308,-757,-12569,}, {1, 1, 1, 0.25,}, 331.665, 2977.017,},
	{Neb3_O3, Cld_N2, {30094, 1949,-44898,}, {1, 1, 1, 0.25,}, 54.274, 3451.156,},
	{Neb3_O3, Cld_N2, {32383,-330,-55693,}, {1, 1, 1, 0.25,}, 205.033, 3583.806,},
	{Neb3_O3, Cld_N2, {34329, 423,-65767,}, {1, 1, 1, 0.25,}, 339.488, 5448.236,},
	{Neb3_O3, Cld_N, {31053, 870,-50433,}, {1, 1, 1, 0.25,}, 208.285, 4357.947,},
	{Neb3_O3, Cld_N2, {33155, 751,-60457,}, {1, 1, 1, 0.25,}, 91.903, 5448.236,},
	{Neb3_O3, Cld_N, {30741, 838,-48100,}, {1, 1, 1, 0.25,}, 126.094, 4857.382,},
	{Neb3_O3, Cld_N2, {30247, 1635,-46218,}, {1, 1, 1, 0.25,}, 286.29, 4357.947,},
	{Neb3_O3, Cld_N, {31750, 370,-52829,}, {1, 1, 1, 0.25,}, 25.302, 4857.382,},
	{Neb3_O3, Cld_N, {31817, 1385,-54203,}, {1, 1, 1, 0.25,}, 212.669, 3881.326,},
	{Neb3_O3, Cld_N, {32634, 920,-57701,}, {1, 1, 1, 0.25,}, 71.161, 3622.568,},
	{Neb3_O3, Cld_N2, {33100, 83,-59180,}, {1, 1, 1, 0.25,}, 231.961, 3583.806,},
	{Neb3_O3, Cld_N, {33540,-378,-61244,}, {1, 1, 1, 0.25,}, 217.547, 2828.99,},
	{Neb3_O3, Cld_N, {34024,-346,-64031,}, {1, 1, 1, 0.25,}, 158.867, 5817.503,},
	{Neb3_O3, Cld_N, {35088,-69,-69163,}, {1, 1, 1, 0.25,}, 142.75, 3676.681,},
	{Neb3_O3, Cld_N, {35834,-574,-72727,}, {1, 1, 1, 0.25,}, 213.196, 3676.681,},
	{Neb3_O3, Cld_N, {36417,-993,-75399,}, {1, 1, 1, 0.25,}, 341.806, 5817.504,},
	{Neb3_O3, Cld_N, {36299,-393,-74316,}, {1, 1, 1, 0.25,}, 141.014, 2330.128,},
	{Neb3_O3, Cld_N, {36865,-507,-76574,}, {1, 1, 1, 0.25,}, 66.711, 3472.819,},
	{Neb3_O3, Cld_N2, {37843,-915,-79881,}, {1, 1, 1, 0.25,}, 206.802, 3472.819,},
	{Neb3_O3, Cld_N, {38453,-1621,-80959,}, {1, 1, 1, 0.25,}, 225.842, 2977.017,},
	{Neb3_O3, Cld_N2, {35221,-669,-69715,}, {1, 1, 1, 0.25,}, 17.864, 5817.504,},
	{Neb3_O3, Cld_N2, {37435,-1307,-78179,}, {1, 1, 1, 0.25,}, 93.672, 2977.017,},
	{Neb3_O4, Cld_N2, {14403,-282, 15848,}, {1, 1, 1, 0.25,}, 322.316, 3451.156,},
	{Neb3_O4, Cld_N2, {17353,-1840, 26611,}, {1, 1, 1, 0.25,}, 262.241, 3583.806,},
	{Neb3_O4, Cld_N, {20889,-556, 36186,}, {1, 1, 1, 0.25,}, 141.684, 5448.236,},
	{Neb3_O4, Cld_N, {16115,-1048, 21251,}, {1, 1, 1, 0.25,}, 325.392, 4357.947,},
	{Neb3_O4, Cld_N, {19307,-568, 30973,}, {1, 1, 1, 0.25,}, 139.717, 5448.236,},
	{Neb3_O4, Cld_N2, {15211,-1173, 19082,}, {1, 1, 1, 0.25,}, 127.28, 4857.382,},
	{Neb3_O4, Cld_N2, {14862,-539, 17108,}, {1, 1, 1, 0.25,}, 268.327, 4357.947,},
	{Neb3_O4, Cld_N2, {16612,-1341, 23730,}, {1, 1, 1, 0.25,}, 266.196, 4857.382,},
	{Neb3_O4, Cld_N, {17459,-333, 24822,}, {1, 1, 1, 0.25,}, 72.062, 3881.326,},
	{Neb3_O4, Cld_N2, {18411,-554, 28310,}, {1, 1, 1, 0.25,}, 244.959, 3622.568,},
	{Neb3_O4, Cld_N, {18573,-1237, 29926,}, {1, 1, 1, 0.25,}, 132.422, 3583.806,},
	{Neb3_O4, Cld_N, {19130,-1558, 31988,}, {1, 1, 1, 0.25,}, 39.376, 2828.99,},
	{Neb3_O4, Cld_N, {20116,-1387, 34634,}, {1, 1, 1, 0.25,}, 73.105, 5817.503,},
	{Neb3_O4, Cld_N2, {21832,-818, 39561,}, {1, 1, 1, 0.25,}, 235.741, 3676.681,},
	{Neb3_O4, Cld_N2, {22869,-1096, 43078,}, {1, 1, 1, 0.25,}, 247.551, 3676.681,},
	{Neb3_O4, Cld_N2, {23616,-1337, 45730,}, {1, 1, 1, 0.25,}, 28.642, 5817.504,},
	{Neb3_O4, Cld_N2, {23307,-792, 44656,}, {1, 1, 1, 0.25,}, 10.009, 2330.128,},
	{Neb3_O4, Cld_N, {23930,-745, 46901,}, {1, 1, 1, 0.25,}, 110.603, 3472.819,},
	{Neb3_O4, Cld_N, {24663,-871, 50293,}, {1, 1, 1, 0.25,}, 51.363, 3472.819,},
	{Neb3_O4, Cld_N, {24534,-1393, 51613,}, {1, 1, 1, 0.25,}, 24.423, 2977.017,},
	{Neb3_O4, Cld_N2, {21866,-1362, 40182,}, {1, 1, 1, 0.25,}, 260.977, 5817.504,},
	{Neb3_O4, Cld_N2, {24075,-1365, 48671,}, {1, 1, 1, 0.25,}, 249.848, 2977.017,},
}

--  Name: MapFunctions v1.18.0
--  Author: Mikali
--  Created: 2004/10/07
--  Updated: 2013/09/30
--  Homepage: http//isometricland.net
--  Discussion:
--  http://forums.relicnews.com/showthread.php?t=48818
--  http://forums.relicnews.com/showthread.php?t=82964 (old thread)
-- http://forums.relicnews.com/showthread.php?t=40779 (old thread)
--  Credits:
--  * MathWorld and Wikipedia for the parametric surface functions used in 
--    "shapeAdd", "harmonographAdd" and probably elsewhere.
--  * GameDev.net for the implicit metaball formula used in "blobAdd".
--  * The function "flokalAdd" is based on 'doodle 4' by bitcraft at 
--    OpenProcessing.org.
--  * Lorenzo Donati at Stack Overflow for the new pseudo random number 
--    generator.


--------------------------------------------------------------------------------
-- Global variables.
--

-- incremental counters
iStartPoints, iPoints, iSpheres, iCameras, iSquadrons, iAsteroids, iSalvage, iPebbles, iClouds, iDustClouds, iNebulas, iDirLights, iRvAsteroids, iRvSquadrons = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
TWO_PI = 2 * PI


--------------------------------------------------------------------------------
--  Name:		appendShape
--  Description:	General shape-adding function utilized internally by the other functions.
--  Syntax:		appendShape(<tPos>, <i>, <tPar>, <j>, <tCoo>, <tRot>)
--  Arguments:
--	<tPos>: a table containing the initial coordinates for the object.
--	<i>: the index of the object within the distribution table.
--	<tPar>: a table containing the object-specific parameters.
--	<j>: the position number of the object within the distribution table.
--	<tCoo>: a table containing the modified coordinates for the object.
--	<tRot>: a table containing the Euler rotation angles.
--  Notes:
--	1. I would like to change the order of the parameters so that <tPos> 
--	   comes after <tRot> since translation is done after rotation. Would 
--	   be good to modify all the other functions to copy this syntax as 
--	   well.
--	2. I should group <i> and <j> together as well.
--------------------------------------------------------------------------------

function appendShape(tPos, i, tPar, j, tCoo, tRot)
	tCoo = vaddV(vrotate(tCoo, tRot), tPos)
	local objType = tPar[2]
	if (objType == "Squadron") then
		local name = tPar[3]
		if (tPar[1] > 1) then
			name = name .. "_" .. j
		end
		--addSquadron(<sSquadronName>, <sSquadronType>, <tPosition>, <iPlayerIndex>, <tRotation>, <iNumberShips>, <bHyperspace>)
		addSquadron(name, tPar[4], vaddV(tCoo, tPar[5]), tPar[6], tPar[7], tPar[8], tPar[9])
		iSquadrons = iSquadrons + 1
	elseif (objType == "Asteroid") then
		--addAsteroid(<sAsteroidType>, <tPosition>, <fRU%>, ?, ?, ?, ?)
		addAsteroid(tPar[3], vaddV(tCoo, tPar[4]), tPar[5], tPar[6], tPar[7], tPar[8], tPar[9])
		iAsteroids = iAsteroids + 1
	elseif (objType == "Salvage") then
		--addSalvage(<sChunkType>, <tPosition>, <fRU%>, ?, ?, ?, ?)
		addSalvage(tPar[3], vaddV(tCoo, tPar[4]), tPar[5], tPar[6], tPar[7], tPar[8], tPar[9])
		iSalvage = iSalvage + 1
	elseif (objType == "Pebble") then
		--addPebble(<sPebbleType>, <tPosition>, ?, ?, ?)
		addPebble(tPar[3], vaddV(tCoo, tPar[4]), tPar[5], tPar[6], tPar[7])
		iPebbles = iPebbles + 1
	elseif (objType == "Cloud") then
		local name = tPar[3]
		if (tPar[1] > 1) then
			name = name .. "_" .. j
		end
		--addCloud(<sCloudName>, <sCloudType>, <tPosition>, <tColor>, ?, <fRadius>)
		addCloud(name, tPar[4], vaddV(tCoo, tPar[5]), tPar[6], tPar[7], tPar[8])
		iClouds = iClouds + 1
	elseif (objType == "DustCloud") then
		local name = tPar[3]
		if (tPar[1] > 1) then
			name = name .. "_" .. j
		end
		--addDustCloud(<sDustCloudName>, <sDustCloudType>, <tPosition>, <tColor>, ?, <fRadius>)
		addDustCloud(name, tPar[4], vaddV(tCoo, tPar[5]), tPar[6], tPar[7], tPar[8])
		iDustClouds = iDustClouds + 1
	elseif (objType == "Nebula") then
		local name = tPar[3]
		if (tPar[1] > 1) then
			name = name .. "_" .. j
		end
		--addNebula(<sNebulaName>, <sNebulaType>, <tPosition>, <tColor>, ?, <fRadius>)
		addNebula(name, tPar[4], vaddV(tCoo, tPar[5]), tPar[6], tPar[7], tPar[8])
		iNebulas = iNebulas + 1
	elseif (objType == "Point") then
		local name = tPar[3]
		if (tPar[1] > 1) then
			name = name .. "_" .. j
		end
		--addPoint(<sPointName>, <tPosition>, <tRotation>)
		addPoint(name, vaddV(tCoo, tPar[4]), tPar[5])
		iPoints = iPoints + 1
	elseif (objType == "StartPoint") then
		local name = "StartPos" .. iStartPoints
		--addPoint(<sPointName>, <tPosition>, <tRotation>)
		addPoint(name, vaddV(tCoo, tPar[4]), tPar[5])
		iStartPoints = iStartPoints + 1
	elseif (objType == "Sphere") then
		local name = tPar[3]
		if (tPar[1] > 1) then
			name = name .. "_" .. j
		end
		--addSphere(<sSphereName>, <tPosition>, <fRadius>)
		addSphere(name, vaddV(tCoo, tPar[4]), tPar[5])
		iSpheres = iSpheres + 1
	elseif (objType == "Camera") then
		local name = tPar[3]
		if (tPar[1] > 1) then
			name = name .. "_" .. j
		end
		--addCamera(<sCameraName>, <tTarget>, <tPosition>)
		addCamera(name, tPar[5], vaddV(tCoo, tPar[4]))
		iCameras = iCameras + 1
	elseif (objType == "DirLight") then
		local name = tPar[3]
		if (tPar[1] > 1) then
			name = name .. "_" .. j
		end
		--createDirLight(<sLightName>, <tPosition>, <tColor>)
		createDirLight(name, vaddV(tCoo, tPar[4]), tPar[5])
		--setLightSpecular (<sLightName>, <tSpecular>)
		setLightSpecular(name, tPar[6])
		iDirLights = iDirLights + 1
	elseif (objType == "ReactiveSquadron") then
		--addReactiveFleetSlot(<sSobGroupName>, <iPlayerIndex>, ?, <tPosition>, ?, ?, ?, <sShipType>)
		addReactiveFleetSlot(tPar[5], tPar[6], tPar[7], vaddV(tCoo, tPar[4]), tPar[8], tPar[9], tPar[10], tPar[3])
		iRvSquadrons = iRvSquadrons + 1
	elseif (objType == "ReactiveAsteroid") then
		--addReactiveFleetResourceSlot(<sResourceType>, <tPosition>, ?, ?, ?)
		addReactiveFleetResourceSlot(tPar[3], vaddV(tCoo, tPar[4]), tPar[5], tPar[6], tPar[7])
		iRvAsteroids = iRvAsteroids + 1
	elseif (objType == "Coordinate") then
		tinsert(tPar[3], tCoo)
		print("function appendShape: adding a coordinate to the coordinate table")
		print("function appendShape: coordinate table length = " .. getn(tPar[3]))
	elseif (objType == "Function") then
		if not (tPar[7]) then
			tPar[7] = {0,0,0,}
		end
		if (tPar[3] == literalAdd) then
			literalAdd(tPar[4], tPar[5], tPar[6], vaddV(tRot, tPar[7]))
		else
			tPar[3](vaddV(tCoo, tPar[4]), tPar[5], tPar[6], vaddV(tRot, tPar[7]))
		end
	else
		print("function appendShape: object class not recognized")
	end
end

function addCoordinate(tCoo, rTable)
	tinsert(rTable, tCoo)
end

function addSOBGroup(sSobName, ...)
	createSOBGroup(sSobName)
	for i = 1, getn(arg) do
		addToSOBGroup(arg[i], sSobName)
	end
end

function doAllSOBGroups(ttable)
	for sobgname, sobgarray in ttable do
		for j = 1, getn(sobgarray) do
			if sobgarray[j][4] == 0 then
				if sobgarray[j][2] == 1 then
					addToSOBGroup(sobgarray[j][1], sobgname)
				else
					for k = 1, sobgarray[j][2] do
						addToSOBGroup(sobgarray[j][1] .. "_" .. k, sobgname)
					end
				end
			end
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		branchAdd
--  Description:	Creates a branching tree-like fractal.
--  Syntax:		branchAdd(<tPos>, <tDst>, {<tDiv>, <tInt>, <tFrq>, <tBeg>, <tEnd>, <tRad>, <tLen>, <tThk>, <tAng>, <iMod>,}, <tRot>, <tSeed>, ...)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tDst>: the distribution table used to populate the shape.
--	<tPar>: a table containing the following ten parameters:
--		<tDiv>: a table containing the minimum and maximum number of new shoots that are generated each time the tree divides.
--		<tInt>: a table containing the minimum and maximum number of segments between instances of division.
--		<tFrq>: a table containing the minimum and maximum number of times the tree divides.
--		<tBeg>: a table containing the minimum and maximum number of segments added to the beginning of the tree.
--		<tEnd>: a table containing the minimum and maximum number of segments added to the end of the tree (at the end of each branch). (Note: this value needs to be greater than zero in order for the last division to be noticable.)
--		<tRad>: a table containing the the minimum and maximum radius of a segment.
--		<tLen>: a table containing the minimum and maximum length of a segment.
--		<tThk>: a table containing the minimum and maximum thickness, as percentages of the radius, of a segment.
--		<tAng>: a table containing the minimum and maximum angle of deviation between segments.
--		<iMod>: 0 is non-random mode, 1 is random placement with steadily decreasing length and radius, 2 is random placement with random length and radius, 3 is a bug-ridden method using splines.
--	<tRot>: a table containing the X, Y and Z rotation angles (degrees) for the entire object.
--	<tSeed>: the seed for the random number functions.
--	The remaining arguments are used internally by the function and should not be modified directly.
--  Notes:
--	1. I suppose I need an <iMod> = 4 mode for a random method using splines, but without decreasing length and radius.
--------------------------------------------------------------------------------

function branchAdd(tPos, tDst, tPar, tRot, tSeed, lastRad, countDiv, countFrq, lastPos, nextPos, tiltDeg, spinDeg)
	local thisPos = {}
	local tDiv, tInt, tFrq, tBeg, tEnd, tRad, tLen, tThk, tAng, iMod = tPar[1], tPar[2], tPar[3], tPar[4], tPar[5], tPar[6], tPar[7], tPar[8], tPar[9], tPar[10]
	local minRad, maxRad, minDist, maxDist, minThck, maxThck = tRad[1], tRad[2], tLen[1], tLen[2], tThk[1]/100, tThk[2]/100
	local minAng, maxAng, minBeg, maxBeg, minEnd, maxEnd = tAng[1], tAng[2], tBeg[1], tBeg[2], tEnd[1], tEnd[2]
	local minDiv, maxDiv, minInt, maxInt, minFrq, maxFrq = tDiv[1], tDiv[2], tInt[1], tInt[2], tFrq[1], tFrq[2]
	local numSeg, numInt, numDiv, numBeg, numEnd, numFrq = 0, 0, 0, 0, 0, 0
	if (lastRad == nil) then
		lastRad = maxRad
		countDiv = 1
		countFrq = minFrq
	else
		countFrq = countFrq - 1
	end
	if (lastPos == nil) then
		lastPos = {0,0,0,}
		nextPos = {0,0,0,}
		tiltDeg, spinDeg = 0, 0
	end
	local thisRad = sqrt(lastRad^2/countDiv)
	-- if set to non-random mode
	if (iMod == 0) then
		numInt, numDiv, numBeg, numEnd, numFrq = maxInt, minDiv, maxBeg, maxEnd, maxFrq
	-- if set to random mode, or random mode with decreasing length and radius
	else
		numInt, numDiv, numBeg, numEnd, numFrq = srandom2(tSeed, minInt, maxInt), srandom2(tSeed, minDiv, maxDiv), srandom2(tSeed, minBeg, maxBeg), srandom2(tSeed, minEnd, maxEnd), srandom2(tSeed, minFrq, maxFrq)
	end
	if (numBeg > 0) then
		numSeg = numBeg
	elseif (numFrq > 0) then
		numSeg = numInt
	elseif (numEnd > 0) then
		numSeg = numEnd
	end
	for k = 1, numSeg do
		local rad, len, thk, angY, angZ = 0, 0, 0, 0, 0
		-- if set to non-random mode
		if (iMod == 0) then
			local sign1, sign2 = srandomSign(tSeed), srandomSign(tSeed)
			rad, len, angY, angZ = maxRad, maxDist, sign1 * maxAng, sign2 * maxAng
		-- if set to random mode with decreasing length and radius
		elseif (iMod == 1) or (iMod == 3) then
			local sign1, sign2, narrw = srandomSign(tSeed), srandomSign(tSeed), srandom3(tSeed, 0.9, 1)
			thisRad = thisRad * narrw
			thk, rad, len, angY, angZ = srandom3(tSeed, minThck, maxThck) * narrw, thisRad, maxDist - (maxDist - minDist)/(numFrq + 1), srandom3(tSeed, minAng, maxAng) * sign1, srandom3(tSeed, minAng, maxAng) * sign2
		-- if set to random mode
		elseif (iMod == 2) then
			local sign1, sign2 = srandomSign(tSeed), srandomSign(tSeed)
			thk, rad, len, angY, angZ = srandom3(tSeed, minThck, maxThck), srandom3(tSeed, minRad, maxRad), srandom3(tSeed, minDist, maxDist), srandom3(tSeed, minAng, maxAng) * sign1, srandom3(tSeed, minAng, maxAng) * sign2
		end
		tiltDeg, spinDeg = tiltDeg + angZ, spinDeg + angY
		thisPos = nextPos
		nextPos = vaddV(nextPos, vrotate({len, 0, 0,}, {0, spinDeg, tiltDeg,}))
		for i, tTab in tDst do
			local Volume1, Volume2 = PI * maxRad^2 * maxDist, PI * rad^2 * len
			local Density = Volume2/Volume1
			local iNum, gradX = floor(tTab[1] * Density + 0.5), len
			for j = 1, iNum do
				-- if set to non-random mode
				if (iMod == 0) then
					local tCoo = {gradX, 0, 0,}
					tCoo = vaddV(thisPos, vrotate(tCoo, {0, spinDeg, tiltDeg,}))
					appendShape(tPos, i, tTab, j, tCoo, tRot)
				-- if set to random mode with decreasing length and radius
				elseif (iMod == 1) then
					local r = sqrt(srandom(tSeed)) * thk * rad + (1 - thk) * rad
					local v, h = srandom3(tSeed, 360), srandom3(tSeed, len)
					local tCoo = {h, r * cos(v), r * sin(v),}
					tCoo = vaddV(thisPos, vrotate(tCoo, {0, spinDeg, tiltDeg,}))
					appendShape(tPos, i, tTab, j, tCoo, tRot)
				-- if set to random mode
				elseif (iMod == 2) then
					local r = sqrt(srandom(tSeed)) * thk * rad + (1 - thk) * rad
					local v, h = srandom3(tSeed, 360), srandom3(tSeed, len)
					local tCoo = {h, r * cos(v), r * sin(v),}
					tCoo = vaddV(thisPos, vrotate(tCoo, {0, spinDeg, tiltDeg,}))
					appendShape(tPos, i, tTab, j, tCoo, tRot)
				-- if set to random method using splines with decreasing length and radius
				elseif (iMod == 3) then
					local t = srandom(tSeed)
					local A = vmidpoint(lastPos, thisPos)
					local B = thisPos
					local C = vmidpoint(thisPos, nextPos)
					local r = sqrt(srandom(tSeed)) * thk * rad + (1 - thk) * rad
					local v = srandom(tSeed, 360)
					local tCirc =
					{
						r * cos(v),
						r * sin(v),
						0,
					}
					local tCoo =
					{
						(1 - t)^2 * A[1] + 2 * (1 - t) * t * B[1] + t^2 * C[1],
						(1 - t)^2 * A[2] + 2 * (1 - t) * t * B[2] + t^2 * C[2],
						(1 - t)^2 * A[3] + 2 * (1 - t) * t * B[3] + t^2 * C[3],
					}
					local tDerivatives =
					{
						2 * (1 - t) * (B[1] - A[1]) + 2 * t * (C[1] - B[1]),
						2 * (1 - t) * (B[2] - A[2]) + 2 * t * (C[2] - B[2]),
						2 * (1 - t) * (B[3] - A[3]) + 2 * t * (C[3] - B[3]),
					}
					local tNormedPos = vrotate(tCirc, vanglesXY(tDerivatives))
					appendShape(tPos, i, tTab, j, vaddV(tCoo, tNormedPos), tRot)
				end
				gradX = gradX - len/iNum
			end
		end
		lastPos = thisPos
	end
	if (numBeg > 0) then
		tBeg = {0, 0,}
		branchAdd(tPos, tDst, {tDiv, tInt, tFrq, tBeg, tEnd, tRad, tLen, tThk, tAng, iMod,}, tRot, tSeed, nil, nil, nil, lastPos, nextPos, tiltDeg, spinDeg)
	elseif (numFrq > 0) then
		if (minFrq >= numFrq) then
			minFrq = numFrq - 1
		end
		tFrq = {minFrq, numFrq - 1,}
		for j = 1, numDiv do
			branchAdd(tPos, tDst, {tDiv, tInt, tFrq, tBeg, tEnd, tRad, tLen, tThk, tAng, iMod,}, tRot, tSeed, thisRad, numDiv, countFrq, lastPos, nextPos, tiltDeg, spinDeg)
		end
	elseif (numEnd > 0) then
		tDiv, tInt, tFrq, tEnd = {0, 0,}, {0, 0,}, {0, 0,}, {0, 0,}
		branchAdd(tPos, tDst, {tDiv, tInt, tFrq, tBeg, tEnd, tRad, tLen, tThk, tAng, iMod,}, tRot, tSeed, thisRad, numDiv, countFrq, lastPos, nextPos, tiltDeg, spinDeg)
	end
end


--------------------------------------------------------------------------------
--  Name:		spline3Add
--  Description:	Creates a Hermite spline-shaped tube connecting any two points using two control points.
--  Syntax:		spline3Add(<tPos>, <tDst>, {<tP1A>, <tP1B>, <tP2A>, <tP2B>, <tRad>, <tThk>,}, <tRot>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tDst>: the distribution table used to populate the shape.
--	<tPar>: a table containing the following six parameters:
--		<tP1A>: a table containing the coordinates of the starting point.
--		<tP1B>: a table containing the coordinates of the first control point.
--		<tP2A>: a table containing the coordinates of the ending point.
--		<tP2B>: a table containing the coordinates of the second control point.
--		<tRad>: a table containing the initial and final radii of the tube.
--		<tThk>: a table containing the initial and final thickness of the tube lining, as a percentage of the radius.
--	<tRot>: a table containing the X, Y and Z rotation angles (degrees) for the entire object.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--	1. Still not sure whether <tThk> should be a percentage instead of a fixed value.
--	2. Needs an <iMode> parameter to output non-random coordinates.
--------------------------------------------------------------------------------

function spline3Add(tPos, tDst, tPar, tRot, tSeed)
	local tP1A, tP1B, tP2A, tP2B, tRad, tThk = tPar[1], tPar[2], tPar[3], tPar[4], tPar[5], tPar[6]
	local begRad, endRad, begThk, endThk = tRad[1], tRad[2], tThk[1]/100, tThk[2]/100
	local P1A_x, P1A_y, P1A_z, P1B_x, P1B_y, P1B_z = tP1A[1], tP1A[2], tP1A[3], tP1B[1], tP1B[2], tP1B[3]
	local P2A_x, P2A_y, P2A_z, P2B_x, P2B_y, P2B_z = tP2A[1], tP2A[2], tP2A[3], tP2B[1], tP2B[2], tP2B[3]

	-- need to reverse the direction of the second control point so that the curves can be stitched neatly together, later
	local C_x = 2 * P2A_x - P2B_x
	local C_y = 2 * P2A_y - P2B_y
	local C_z = 2 * P2A_z - P2B_z

	for i, tTab in tDst do
		for j = 1, tTab[1] do
			local t, phi = srandom(tSeed), srandom(tSeed, 360)
			local r = begRad + (endRad - begRad) * t
			local h = begThk + (endThk - begThk) * t
			r = sqrt(srandom(tSeed)) * h * r + (1 - h) * r
			local tCirc =
			{
				r * cos(phi),
				r * sin(phi),
				0,
			}
			local tCoo =
			{
				(P2A_x + 3 * P1B_x - 3 * C_x - P1A_x) * t^3 + (3 * C_x - 6 * P1B_x + 3 * P1A_x) * t^2 + (3 * P1B_x - 3 * P1A_x) * t + P1A_x,
				(P2A_y + 3 * P1B_y - 3 * C_y - P1A_y) * t^3 + (3 * C_y - 6 * P1B_y + 3 * P1A_y) * t^2 + (3 * P1B_y - 3 * P1A_y) * t + P1A_y,
				(P2A_z + 3 * P1B_z - 3 * C_z - P1A_z) * t^3 + (3 * C_z - 6 * P1B_z + 3 * P1A_z) * t^2 + (3 * P1B_z - 3 * P1A_z) * t + P1A_z,
			}
			local tDerivatives =
			{
				(P2A_x + 3 * P1B_x - 3 * C_x - P1A_x) * 3 * t^2 + (3 * C_x - 6 * P1B_x + 3 * P1A_x) * 2 * t + (3 * P1B_x - 3 * P1A_x),
				(P2A_y + 3 * P1B_y - 3 * C_y - P1A_y) * 3 * t^2 + (3 * C_y - 6 * P1B_y + 3 * P1A_y) * 2 * t + (3 * P1B_y - 3 * P1A_y),
				(P2A_z + 3 * P1B_z - 3 * C_z - P1A_z) * 3 * t^2 + (3 * C_z - 6 * P1B_z + 3 * P1A_z) * 2 * t + (3 * P1B_z - 3 * P1A_z),
			}
			local tNormedPos = vrotate(tCirc, vanglesXY(tDerivatives))
			appendShape(tPos, i, tTab, j, vaddV(tCoo, tNormedPos), tRot)
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		spline2Add
--  Description:	Creates a quadratic spline-shaped tube connecting any two points using a control point.
--  Syntax:		spline2Add(<tPos>, <tDst>, {<tP1>, <tP2>, <tP3>, <tRad>, <tThk>,}, <tRot>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tDst>: the distribution table used to populate the shape.
--	<tPar>: a table containing the following six parameters:
--		<tP1>: a table containing the coordinates of the starting point.
--		<tP2>: a table containing the coordinates of the control point.
--		<tP3>: a table containing the coordinates of the ending point.
--		<tRad>: a table containing the initial and final radii of the tube.
--		<tThk>: a table containing the initial and final thickness of the tube lining, as a percentage of the radius.
--	<tRot>: a table containing the X, Y and Z rotation angles (degrees) for the entire object.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--	1. Still not sure whether <tThk> should be a percentage instead of a fixed value.
--	2. Needs an <iMode> parameter to output non-random coordinates.
--------------------------------------------------------------------------------

function spline2Add(tPos, tDst, tPar, tRot, tSeed)
	local tP1, tP2, tP3, tRad, tThk = tPar[1], tPar[2], tPar[3], tPar[4], tPar[5]
	local begRad, endRad, begThk, endThk = tRad[1], tRad[2], tThk[1]/100, tThk[2]/100
	for i, tTab in tDst do
		for j = 1, tTab[1] do
			local t, phi = srandom(tSeed), srandom(tSeed, 360)
			local r = begRad + (endRad - begRad) * t
			local h = begThk + (endThk - begThk) * t
			r = sqrt(srandom(tSeed)) * h * r + (1 - h) * r
			local tCirc =
			{
				r * cos(phi),
				r * sin(phi),
				0,
			}
			local tCoo =
			{
				(1 - t)^2 * tP1[1] + 2 * (1 - t) * t * tP2[1] + t^2 * tP3[1],
				(1 - t)^2 * tP1[2] + 2 * (1 - t) * t * tP2[2] + t^2 * tP3[2],
				(1 - t)^2 * tP1[3] + 2 * (1 - t) * t * tP2[3] + t^2 * tP3[3],
			}
			local tDerivatives =
			{
				2 * (1 - t) * (tP2[1] - tP1[1]) + 2 * t * (tP3[1] - tP2[1]),
				2 * (1 - t) * (tP2[2] - tP1[2]) + 2 * t * (tP3[2] - tP2[2]),
				2 * (1 - t) * (tP2[3] - tP1[3]) + 2 * t * (tP3[3] - tP2[3]),
			}
			local tNormedPos = vrotate(tCirc, vanglesXY(tDerivatives))
			appendShape(tPos, i, tTab, j, vaddV(tCoo, tNormedPos), tRot)
		end
	end
end

--------------------------------------------------------------------------------
--  Name:		blobAdd
--  Description:	Creates a network of metaballs, or blobs, based on the formula for electromagnetic fields.
--  Syntax:		blobAdd(<tPos>, <tDst>, {<tBlobs>, <fThrsh1>, <fThrsh2>, <tScale>,}, <tRot>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tDst>: the distribution table used to populate the shape.
--	<tPar>: a table containing the following four parameters:
--		<tBlobs>: a table containing the location coordinates and strength of each blob.
--		<fThrsh1>: threshold 1 in units of field strength.
--		<fThrsh2>: threshold 2 in units of field strength.
--		<tScale>: scale the entire shape by these amounts in the {x,y,z} directions.
--	<tRot>: a table containing the X, Y and Z rotation angles (degrees) for the entire object.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--	1. This function is kind of a mess, but the results look OK. I would 
--	   rather plot points parametrically instead of plotting them randomly 
--	   and then testing whether they're inside the blob or not. 
--	   Unfortunately, the function is an implicit isosurface.
--	2. Negative field strength/radius doesn't work here like it does in 
--	   "fieldAdd". Nor does it make sense to I think.
--	3. Should this function use the "fieldCalc" function to calculate 
--	   field strength?
--	4. See Method 1 at: http://www.geogebra.org/en/upload/files/english/Michael_Horvath/Metaballs/geogebra_metaballs.htm
--------------------------------------------------------------------------------

function blobAdd(tPos, tDst, tPar, tRot, tSeed)
	local tBlobs = tPar[1]
	local Blob_threshold_1 = tPar[2]
	local Blob_threshold_2 = tPar[3]
	local Blob_scale = tPar[4]

	-- calculate the bounding box enclosing the blobs
	local Blob_min = {0,0,0,}
	local Blob_max = {0,0,0,}
	for j, jBlob in tBlobs do
		local Blob_vector = jBlob[1]
		local Blob_radius = jBlob[2]
		Blob_min = {min(Blob_min[1], Blob_vector[1] - Blob_radius), min(Blob_min[2], Blob_vector[2] - Blob_radius), min(Blob_min[3], Blob_vector[3] - Blob_radius),}
		Blob_max = {max(Blob_max[1], Blob_vector[1] + Blob_radius), max(Blob_max[2], Blob_vector[2] + Blob_radius), max(Blob_max[3], Blob_vector[3] + Blob_radius),}
	end

	for i, tTab in tDst do
		local jCount = 1
		local jMax = tTab[1]
		while (jCount <= jMax) do
			-- generate a new point somewhere within the blob's bounding box
			local Vector_new = {srandom3(tSeed, Blob_min[1], Blob_max[1]), srandom3(tSeed, Blob_min[2], Blob_max[2]), srandom3(tSeed, Blob_min[3], Blob_max[3]),}
	--		local Vector_new = {random3(Blob_min[1], Blob_max[1]), random3(Blob_min[2], Blob_max[2]), random3(Blob_min[3], Blob_max[3]),}

			-- get the field strength at that point
			local Actual_strength = 0
			for j, jBlob in tBlobs do
				local Blob_vector = jBlob[1]
				local Blob_radius = jBlob[2]
				Actual_strength = Actual_strength + (Blob_radius / sqrt((Vector_new[1] - Blob_vector[1])^2 + (Vector_new[2] - Blob_vector[2])^2 + (Vector_new[3] - Blob_vector[3])^2))
			end

			if (Actual_strength > Blob_threshold_1) then
				-- the field strength, normalized to between 0 and 1
				local Strength_ratio = (Actual_strength - Blob_threshold_1)/(Blob_threshold_2 - Blob_threshold_1)
				-- points should be denser where the strength is greater
				if (Strength_ratio > sqrt(srandom3(tSeed))) then
					-- scale all coordinates by this amount to make the blobs look flatter and better
					Vector_new = vmultiplyV(Vector_new, Blob_scale)
					appendShape(tPos, i, tTab, jCount, Vector_new, tRot)
					jCount = jCount + 1
				end
			end
		end
	end
end

-- old version not using distributions
function blobAdd2(tPos, xNil, tPar, tRot, tSeed)
	local tBlobs = tPar[1]
	local Point_number = tPar[2]
	local Blob_threshold_1 = tPar[3]
	local Blob_threshold_2 = tPar[4]
	local Blob_scale = tPar[5]

	-- calculate the bounding box enclosing the blobs
	-- not really a good method...
	local Blob_min = {0,0,0,}
	local Blob_max = {0,0,0,}
	for j, jBlob in tBlobs do
		local Blob_vector = jBlob[1]
		local Blob_radius = jBlob[2]
		Blob_min = {min(Blob_min[1], Blob_vector[1] - Blob_radius), min(Blob_min[2], Blob_vector[2] - Blob_radius), min(Blob_min[3], Blob_vector[3] - Blob_radius),}
		Blob_max = {max(Blob_max[1], Blob_vector[1] + Blob_radius), max(Blob_max[2], Blob_vector[2] + Blob_radius), max(Blob_max[3], Blob_vector[3] + Blob_radius),}
	end

	local Point_padding = 500		-- put in tPar?
	local Point_maxradius = 1000;
	local Point_list = {}
	local Point_count = 1
	while (Point_count <= Point_number) do
		-- generate a new point somewhere within the blob's bounding box
		local Vector_new = {srandom3(tSeed, Blob_min[1], Blob_max[1]), srandom3(tSeed, Blob_min[2], Blob_max[2]), srandom3(tSeed, Blob_min[3], Blob_max[3]),}
--		local Vector_new = {random3(Blob_min[1], Blob_max[1]), random3(Blob_min[2], Blob_max[2]), random3(Blob_min[3], Blob_max[3]),}

		-- get the field strength at that point
		local Actual_strength = 0
		for j, jBlob in tBlobs do
			local Blob_vector = jBlob[1]
			local Blob_radius = jBlob[2]
			Actual_strength = Actual_strength + (Blob_radius / sqrt((Vector_new[1] - Blob_vector[1])^2 + (Vector_new[2] - Blob_vector[2])^2 + (Vector_new[3] - Blob_vector[3])^2))
		end

		if (Actual_strength > Blob_threshold_1) then
			-- the field strength, normalized to between 0 and 1
			local Strength_ratio = (Actual_strength - Blob_threshold_1)/(Blob_threshold_2 - Blob_threshold_1)
			local Random_ratio = Strength_ratio * srandom3(tSeed)
			-- points should be denser where the strength is greater
			if (Random_ratio > sqrt(srandom3(tSeed))) then
				-- the point's radius, points should be larger where the strength is greater
				local Radius_new = min(Point_maxradius * Random_ratio, Point_maxradius)

				-- scale all coordinates by this amount to make the blobs look flatter and better
				Vector_new = vmultiplyV(Vector_new, Blob_scale)

				-- make sure the asteroids are not too close to each other (TOO SLOW!!!)
				local Pass_bool = 1

				local Point_count_sub = 1
				while (Point_count_sub < Point_count) do
					local Vector_old = Point_list[Point_count_sub][1]
					local Radius_old = Point_list[Point_count_sub][2]
					local Distance = vdistance(Vector_old, Vector_new)
					local Radius_all = max(Radius_old, Radius_new, Point_padding)
					if (Distance <= Radius_all) then
						Pass_bool = 0
						break
					end
					Point_count_sub = Point_count_sub + 1
				end

				-- make sure no points are equal
--				local Point_count_sub = 1
--				while (Point_count_sub < Point_count) do
--					local Vector_old = Point_list[Point_count_sub][1]
--					if (veq(Vector_old, Vector_new) == 1) then
--						Pass_bool = 0
--						print("\tPoint_count = " .. Point_count .. "\n\tVector_old = " .. vstr(Vector_old) .. "\tPoint_count_sub = " .. Point_count_sub .. "\n\tVector_new = " .. vstr(Vector_new))
--						break
--					end
--					Point_count_sub = Point_count_sub + 1
--				end

				if (Pass_bool == 1) then
					-- the square roots here may not be necessary
					-- raising the threshold might achieve the same
					-- but the test map looks good with them
					if (Random_ratio <= sqrt(2/10)) then
						--appendShape(tPos, i, tPar, j, tCoo, tRot)
						--addAsteroid(<sAsteroidType>, <tPosition>, <fRU%>, ?, ?, ?, ?)
	--					appendShape(tPos, 1, {1, "Asteroid", "Asteroid_1", {0,0,0,}, 100, 0, 0, 0, 0,}, Point_count, Vector_new, tRot)
						appendShape(tPos, 1, {1, "Pebble", "Pebble_1", {0,0,0,}, 100, 0, 0, 0, 0,}, Point_count, Vector_new, tRot)
					elseif (Random_ratio <= sqrt(4/10)) then
						appendShape(tPos, 1, {1, "Asteroid", "Asteroid_2", {0,0,0,}, 100, 0, 0, 0, 0,}, Point_count, Vector_new, tRot)
					elseif (Random_ratio <= sqrt(6/10)) then
						appendShape(tPos, 1, {1, "Asteroid", "Asteroid_3", {0,0,0,}, 100, 0, 0, 0, 0,}, Point_count, Vector_new, tRot)
					elseif (Random_ratio <= sqrt(8/10)) then
						appendShape(tPos, 1, {1, "Asteroid", "Asteroid_4", {0,0,0,}, 100, 0, 0, 0, 0,}, Point_count, Vector_new, tRot)
					elseif (Random_ratio <= sqrt(10/10)) then
						appendShape(tPos, 1, {1, "Asteroid", "Asteroid_5", {0,0,0,}, 100, 0, 0, 0, 0,}, Point_count, Vector_new, tRot)
					end
					--print("Point_count = " .. Point_count .. "\nVector_new = " .. vstr(Vector_new))
					Point_list[Point_count] = {Vector_new, Radius_new}
					Point_count = Point_count + 1
				end
			end
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		fieldAdd
--  Description:	Similar to blobAdd, except it produces a heightmap based on the field strength instead of 3D blobs.
--  Syntax:		fieldAdd(<tPos>, <tRes>, {<tBlobs>, <fThrshMin>, <fThrshMax>, <fFieldSize>, <fStepHeight>,}, <tRot>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tRes>: a table containing the parameters of the outputted pebble or asteroid.
--	<tPar>: a table containing the following four parameters:
--		<tBlobs>: a table containing the location coordinates and strength of each blob.
--		<fThrshMin>: minimum threshold in units of field strength.
--		<fThrshMax>: maximum threshold in units of field strength.
--		<fFieldSize>: the size of the entire field in X, Y, Z dimensions.
--		<fStepHeight>: the height of one unit of field strength.
--	<tRot>: a table containing the X, Y and Z rotation angles (degrees) for the entire object.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--	1. The output looks kind of weird near the peaks of the functions 
--	   unless you use a large value for <fFieldSize>.
--	2. See Method 1 at: http://www.geogebra.org/en/upload/files/english/Michael_Horvath/Metaballs/geogebra_metaballs.htm
--------------------------------------------------------------------------------

function fieldAdd(tPos, tTab, tPar, tRot, xNil)
	local tBlobs = tPar[1]
	local Blob_threshold_1 = tPar[2]
	local Blob_threshold_2 = tPar[3]
	local field_size = tPar[4]
	local step_height = tPar[5]
	local jCount = 0
	local jMax = floor(sqrt(tTab[1]))
	local jStep = field_size/jMax
	for j = 0, jMax do
		for k = 0, jMax do
			-- generate a new point
			local Vector_new = {j * jStep - field_size/2, 0, k * jStep - field_size/2,}

			-- get the field strength at that point
			local Actual_strength = fieldCalc(tBlobs, Vector_new, Blob_threshold_1, Blob_threshold_2)

			Vector_new = {Vector_new[1], Actual_strength * step_height, Vector_new[3],}

			jCount = jCount + 1
			appendShape(tPos, i, tTab, jCount, Vector_new, tRot)
		end
	end
end

-- calculate the strength of an electromagnetic field at a given point
function fieldCalc(tBlobs, tVector, minThrsh, maxThrsh)
	-- get the field strength at that point
	local Actual_strength = 0
	for j, jBlob in tBlobs do
		local Blob_vector = jBlob[1]
		local Blob_radius = jBlob[2]
		Actual_strength = Actual_strength + Blob_radius / sqrt((tVector[1] - Blob_vector[1])^2 + (tVector[2] - Blob_vector[2])^2 + (tVector[3] - Blob_vector[3])^2)
	end
	return max(min(Actual_strength, maxThrsh), minThrsh)
end

--------------------------------------------------------------------------------
--  Name:		flokalAdd
--  Description:	Creates a kaleidoscopic bubble and swirl pattern kind of like a doily.
--  			Based on 'doodle 4' by bitcraft, http://www.openprocessing.org/sketch/17344 
--  Syntax:		flokalAdd(<tPos>, <tRes>, {<iNx>, <iNy>, <iXmin>, <iSx>, <iSy>, <iSym>, <fEcc>, <bInside>, <fScale>}, <tRot>, <xNil>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tRes>: a table containing the parameters of the outputted pebble or asteroid.
--	<tPar>: a table containing the following parameters:
--		<iNx>: the number of "horizontal" equipotential lines per charge, not taking into account iXmin.
--		<iNy>: the number of "vertical" flow lines per charge.
--		<iXmin>: size of the empty hole for each charge, measured in "horizontal" lines.
--		<iSx>: the number of extra items spaced between "horizontal" lines.
--		<iSy>: the number of extra items spaced between "vertical" lines.
--		<iSym>: number of charges arranged around the origin.
--		<fEcc>: the eccentricity of the shape, i.e. the amount the shape diverges from a circle.
--		<bInside>: are the curved lines inside or outside of the reference circle?
--		<fScale>: scale the whole shape by this amount in all directions.
--	<tRot>: a table containing the X, Y and Z rotation angles (degrees) for the entire object.
--	<xNil>: this should always remain "nil".
--  Notes:
--	1. Not sure if <fEcc> has the same meaning as the eccentricity of an ellipse.
--------------------------------------------------------------------------------

function flokalAdd(tPos, tRes, tPar, tRot, xNil)
	local iNx = tPar[1];
	local iNy = tPar[2];
	local iXmin = tPar[3];
	local iSx = tPar[4];
	local iSy = tPar[5];
	local iSym = tPar[6];
	local fEcc = tPar[7];
	local bInside = tPar[8];
	local fScale = tPar[9];
	local pow = function(fA, fB)
		return fA^fB
	end
	local dist = function(fX1, fY1, fX2, fY2)
		return sqrt(%pow(fX2 - fX1, 2) + %pow(fY2 - fY1, 2))
	end
	local mag = function(fX, fY)
		return %dist(fX, fY, 0, 0)
	end
	local norm = function()
		local fY1 = 0;
		local fX1 = 0;
		local fX2 = exp(fX1) * cos(deg(fY1));
		local fY2 = exp(fX1) * sin(deg(fY1)) + %fEcc;
		local fD = 0;
		if (%bInside == 1) then
			fD = %pow(%mag(fX2, fY2),  1/%iSym);
		else
			fD = %pow(%mag(fX2, fY2), -1/%iSym);
		end
		local fArg = rad(atan2(fX2, fY2)) * -1/%iSym;
		local fX3 = fD * cos(deg(fArg))/TWO_PI;
		local fY3 = fD * sin(deg(fArg))/TWO_PI;
		return %mag(fX3, fY3)
	end

	-- calculate the distance from the origin to the center of each eye, then use it to normalize the shape to within 1 unit of the center
	local fNorm = norm();

	local fn = function(fX, fY)
		local aP = {};
		local fX1 = exp(fX) * cos(deg(fY));
		local fY1 = exp(fX) * sin(deg(fY)) + %fEcc;
		local fD = 0;
		if (%bInside == 1) then
			fD = %pow(%mag(fX1, fY1),  1/%iSym);
		else
			fD = %pow(%mag(fX1, fY1), -1/%iSym);
		end
		local fArg = rad(atan2(fX1, fY1)) * -1/%iSym;
		for i = 0, %iSym - 1 do
			local fX2 = fD * cos(deg(fArg + i * TWO_PI/%iSym))/TWO_PI;
			local fY2 = fD * sin(deg(fArg + i * TWO_PI/%iSym))/TWO_PI;
			aP[i + 1] = {fX2, fY2};
		end
		return aP
	end
	local lines = function(aP1, aP2)
		for i = 0, %iSym - 1 do
			local fX1 = aP1[i + 1][0 + 1];
			local fY1 = aP1[i + 1][1 + 1];
			local fX2 = aP2[i + 1][0 + 1];
			local fY2 = aP2[i + 1][1 + 1];
			local tCoo = {fX1 * %fScale/%fNorm, 0, fY1 * %fScale/%fNorm,}
			appendShape(%tPos, 1, %tRes, 0, tCoo, %tRot)
		end
	end

	-- for each vertical flowline
	for i = 0, iNy - 1 do
		local fY = i * TWO_PI/iNy;
		for j = iXmin * iSx, iNx * iSx - 1 do
			-- make sure we don't have overlapping objects
			if (mod(j, iSx) > 0) then
				local fX1 = j * TWO_PI/iNx/iSx;
				local fX2 = (j + 1) * TWO_PI/iNx/iSx;
				lines(fn(fX1, fY), fn(fX2, fY))
			end
		end
	end
	-- for each horizontal equipotential line
	for i = iXmin, iNx do
		local fX = i * TWO_PI/iNx;
		for j = 0, iNy * iSy - 1 do
			local fY1 = j * TWO_PI/iNy/iSy;
			local fY2 = (j + 1) * TWO_PI/iNy/iSy;
			lines(fn(fX, fY1), fn(fX, fY2))
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		ringAdd
--  Description:	Creates an elliptical ring centered on one focus.
--  Syntax:		ringAdd(<tPos>, <tDst>, {<fAx1>, <fAx2>, <fThk>, <fHgh>, <tArc>, <iMod>,}, <tRot>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tDst>: the distribution table used to populate the shape.
--	<tPar>: a table containing the following six parameters:
--		<fAx1>: the length of axis 1.
--		<fAx2>: the length of axis 2.
--		<fThk>: the distance from the outer radius to the inner radius (varies according to <iMod>).
--		<fHgh>: the height of the ring, relative to the plane.
--		<tArc>: a table containing the beginning and ending degrees of the arc.
--		<iMod>: if 0, then non-random mode. If 1, then random mode w/ gradual width. If 2, then random mode w/ even width.
--	<tRot>: a table containing the X, Y and Z rotation angles (degrees) for the entire object.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--	1. Should maybe add an option to center the shape on the origin instead of only the foci.
--------------------------------------------------------------------------------

function ringAdd(tPos, tDst, tPar, tRot, tSeed)
	local fAx1, fAx2, fThk, fHgh, tArc, iMod = tPar[1], tPar[2], tPar[3], tPar[4], tPar[5], tPar[6]
	local fFoc = sqrt(abs(fAx1^2 - fAx2^2))
	local tCoo, minArc, maxArc = {}, tArc[1], tArc[2]
	for i, tTab in tDst do
		local u, w, h, arc, iNum = 0, 0, 0, 0, tTab[1]
		for j = 1, iNum do
			if (iMod == 2) then
				u = srandom3(tSeed, minArc, maxArc)
				tCoo =
				{
					cos(u) * fAx2 - srandom3(tSeed, fThk),
					random3(fHgh) - fHgh/2,
					sin(u) * fAx1 - srandom3(tSeed, fThk),
				}
			elseif (iMod == 1) then
				u = srandom3(tSeed, minArc, maxArc)
				tCoo =
				{
					cos(u) * (fAx2 - srandom3(tSeed, fThk)),
					srandom3(tSeed, fHgh) - fHgh/2,
					sin(u) * sqrt((fAx2 - srandom3(tSeed, fThk))^2 - fAx2^2 + fAx1^2),
				}
			elseif (iMod == 0) then
				u = minArc + arc
				tCoo =
				{
					cos(u) * (fAx2 + fThk/-2 + w),
					fHgh/-2 + h,
					sin(u) * (fAx1 + fThk/-2 + w),
				}
				arc, w, h = arc + (maxArc - minArc)/iNum, w + fThk/iNum, h + fHgh/iNum
			end
			tCoo = vaddV(tCoo, {0,0,fFoc,})
			appendShape(tPos, i, tTab, j, tCoo, tRot)
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		globeAdd
--  Description:	Creates a series of rings in the shape of a sphere, like the latitudinal and longitudinal lines of a globe.
--  Syntax:		globeAdd(<tPos>, <tDst>, {<fRad>, <iLat>, <iLon>, <fThk>, <fHgh>, <tArc>, <iMod>,}, <xNil>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tPar>: a table containing the following seven parameters:
--		<fRad>: the radius of the sphere.
--		<iLat>: the number of latitudinal rings.
--		<iLon>: the number of longitudinal rings.
--		<fThk>: see the description for the "ringAdd" function.
--		<fHgh>: see the description for the "ringAdd" function.
--		<tArc>: see the description for the "ringAdd" function.
--		<iMod>: see the description for the "ringAdd" function.
--	<xNil>: this argument is ignored and is used only to adhere to the API.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--  	1. Beware that objects may overlap where the longitudinal rings intersect at the poles.
--	2. Need to get <tRot> working for this function.
--------------------------------------------------------------------------------

function globeAdd(tPos, tDst, tPar, xNil, tSeed)
	local lat, lon, u, X, Y = 0, 0, 0, 0, 0
	local fRad, iLat, iLon, fThk, fHgh, tArc, iMod = tPar[1], tPar[2], tPar[3], tPar[4], tPar[5], tPar[6], tPar[7]
	for i = 1, iLat do
		lat = lat + 360/(iLat * 2 + 2)
		u = lat
		X, Y = cos(u) * fRad, sin(u) * fRad
		-- ringAdd(<tPos>, <tDst>, {<fAx1>, <fAx2>, <fThk>, <fHgh>, <tArc>, <iMod>,}, <tRot>, <tSeed>)
		ringAdd(vaddV(tPos, {0, X, 0,}), tDst, {Y, Y, fThk, fHgh, tArc, iMod,}, {0, 0, 0,}, tSeed)
	end
	for i = 1, iLon do
		lon = lon + 360/iLon
		-- ringAdd(<tPos>, <tDst>, {<fAx1>, <fAx2>, <fThk>, <fHgh>, <tArc>, <iMod>,}, <tRot>, <tSeed>)
		ringAdd(tPos, tDst, {fRad, fRad, fThk, fHgh, tArc, iMod,}, {0, lon, 90,}, tSeed)
	end
end


--------------------------------------------------------------------------------
--  Name:		shapeAdd
--  Description:	Creates one of several available shapes.
--  Syntax:		shapeAdd(<tPos>, <tDst>, {<sLay>, ...}, <tRot>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tDst>: the distribution table used to populate the shape.
--	<tPar>: a table containing up to several parameters: <sLay> and <fA>, <fB>, ..., etc.
--		<sLay>: the type of shape to generate.
--		If <sLay> is "Cylinder", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the length of axis 3, <fD> equals the thickness, and <fE> is zero.
--		If <sLay> is "Cone", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the length of axis 3, <fD> equals the thickness, and <fE> is zero.
--		If <sLay> is "Ellipsoid", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the length of axis 3, <fD> equals the thickness, and <fE> is zero.
--		If <sLay> is "Cuboid", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the length of axis 3, <fD> equals the thickness, and <fE> is zero.
--		If <sLay> is "Toroid", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the width of the tube, <fD> equals the thickness, and <fE> equals the height of the tube.
--		If <sLay> is "Helicoid", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the length of axis 3, and <fD> equals the width (thickness is not supported), <fE> is the number of revolutions.
--		If <sLay> is "Paraboloid", then <fA> equals the length of axis 1 at a height of 1000 units, <fB> equals the length of axis 2 at a height of 1000 units, <fC> equals the length of axis 3, <fD> equals the thickness, and <fE> is zero.
--		If <sLay> is "Hyperboloid", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the length of axis 3, <fD> equals the thickness, and <fE> is zero.
--		If <sLay> is "Astroid", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the length of axis 3, <fD> equals the thickness, and <fE> is zero.
--		If <sLay> is "Funnel", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals roughly the inverse of the length of axis 3 for large numbers of objects, <fD> equals the thickness, and <fE> is zero.
--		If <sLay> is "Dini", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the distance between each twist, <fD> is zero, and <fE> is the number of twists.
--		If <sLay> is "Corkscrew", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the height of the screw, <fD> is zero, and <fE> is zero.
--		If <sLay> is "Seashell", then <fA> equals the length of axis 1 of the tube, <fB> equals the length of axis 2 of the tube, <fC> equals the vertical separation between revolutions, <fD> equals the radius of the center gap, and <fE> equals the number of revolutions.
--		If <sLay> is "SineDisc", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the maximum height of the wave, <fD> zero, and <fE> equals the frequency of the wave pattern.
--		If <sLay> is "SinePlane", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the maximum height of the wave, <fD> zero, and <fE> equals the frequency of the wave pattern.
--		If <sLay> is "Moebius", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals half the width of the strip, <fD> is zero, and <fE> is zero.
--		If <sLay> is "Klein", then <fA> equals the scaling along the x-axis, <fB> equals the scaling along the z-axis, <fC> equals the scaling along the y-axis, <fD> is zero, and <fE> is zero.
--		If <sLay> is "Klein8", then <fA> equals the scaling along the x-axis, <fB> equals the scaling along the z-axis, <fC> equals the scaling along the y-axis, <fD> is zero, and <fE> is the radius of the circle before scaling.
--		If <sLay> is "Boy", then <fA> equals the scaling along the x-axis, <fB> equals the scaling along the z-axis, <fC> equals the scaling along the y-axis.
--		If <sLay> is "Rectangle", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the length of axis 3, and <fD> equals the thickness.
--		If <sLay> is "Ellipse", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the length of axis 3, and <fD> equals the thickness.
--		If <sLay> is "Triangle", [...to do.]
--		If <sLay> is "Parabola", then <fA> equals the distance between the vertex and the focus, <fB> equals the length, <fC> equals the height, and <fD> equals the thickness.
--		If <sLay> is "Hyperbola", then <fA> equals the length of axis 1, <fB> equals the length of axis 2, <fC> equals the distance from the origin to one of the foci, <fD> equals the thickness.
--		If <sLay> is "Catenary", [...to do.]
--		If <sLay> is "Hypotrochoid", then <fA> equals the radius of the greater circle, <fB> equals the radius of the lesser circle, <fC> equals the radius of the sphere sweep, <fD> equals the distance from the center of the lesser circle, and <fE> equals the number of revolutions.
--		If <sLay> is "Epitrochoid", then <fA> equals the radius of the greater circle, <fB> equals the radius of the lesser circle, <fC> equals the radius of the sphere sweep, <fD> equals the distance from the center of the lesser circle, and <fE> equals the number of revolutions.
--	<tRot>: a table containing the X, Y and Z Euler rotation angles, in degrees, for the entire object.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--	1. Should be able to plot non-random points as well as random ones. Lots of extra work though.
--------------------------------------------------------------------------------

function shapeAdd(tPos, tDst, tPar, tRot, tSeed)
	local sLay = tPar[1]
	for i, tTab in tDst do
		for j = 1, tTab[1] do
			local tCoo = {}
			if (sLay == "Cuboid") then
				tCoo = makeCuboid(tPar, tSeed)
			elseif (sLay == "Ellipsoid") then
				tCoo = makeEllipsoid(tPar, tSeed)
			elseif (sLay == "Cylinder") then
				tCoo = makeCylinder(tPar, tSeed)
			elseif (sLay == "Cone") then
				tCoo = makeCone(tPar, tSeed)
			elseif (sLay == "Toroid") then
				tCoo = makeToroid(tPar, tSeed)
			elseif (sLay == "Helicoid") then
				tCoo = makeHelicoid(tPar, tSeed)
			elseif (sLay == "Paraboloid") then
				tCoo = makeParaboloid(tPar, tSeed)
			elseif (sLay == "Hyperboloid") then
				tCoo = makeHyperboloid(tPar, tSeed)
			elseif (sLay == "Astroid") then
				tCoo = makeAstroid(tPar, tSeed)
			elseif (sLay == "Funnel") then
				tCoo = makeFunnel(tPar, tSeed)
			elseif (sLay == "Dini") then
				tCoo = makeDini(tPar, tSeed)
			elseif (sLay == "Corkscrew") then
				tCoo = makeCorkscrew(tPar, tSeed)
			elseif (sLay == "Seashell") then
				tCoo = makeSeashell(tPar, tSeed)
			elseif (sLay == "SineDisc") then
				tCoo = makeSineDisc(tPar, tSeed)
			elseif (sLay == "SinePlane") then
				tCoo = makeSinePlane(tPar, tSeed)
			elseif (sLay == "Moebius") then
				tCoo = makeMoebius(tPar, tSeed)
			elseif (sLay == "Klein") then
				tCoo = makeKlein(tPar, tSeed)
			elseif (sLay == "Klein8") then
				tCoo = makeKlein8(tPar, tSeed)
			elseif (sLay == "Kuen") then
				tCoo = makeKuen(tPar, tSeed)
			elseif (sLay == "Boy") then
				tCoo = makeBoy(tPar, tSeed)
			elseif (sLay == "Rectangle") then
				tCoo = makeRectangle(tPar, tSeed)
			elseif (sLay == "Ellipse") then
				tCoo = makeEllipse(tPar, tSeed)
			--elseif (sLay == "Triangle") then
				-- to do
			elseif (sLay == "Parabola") then
				tCoo = makeParabola(tPar, tSeed)
			elseif (sLay == "Hyperbola") then
				tCoo = makeHyperbola(tPar, tSeed)
			--elseif (sLay == "Catenary") then
				-- to do
			elseif (sLay == "Hypotrochoid") then
				tCoo = makeHypotrochoid(tPar, tSeed)
			elseif (sLay == "Epitrochoid") then
				tCoo = makeEpitrochoid(tPar, tSeed)
			else
				print("function shapeAdd: shape not recognized")
			end
			appendShape(tPos, i, tTab, j, tCoo, tRot)
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		harmonographAdd
--  Description:	Creates a squiggly curving tube. The shape is similar to that produced by a harmonograph, except in three dimensions.
--			See for more info: http://en.wikipedia.org/wiki/Harmonograph
--  Syntax:		harmonographAdd(<tPos>, <tDst>, {{<fA>, <fF>, <fP>, <fD>}, <tGrp2>, <tGrp3>, <tGrp4>, <tGrp5>, <tGrp6>, <fTim>, <fRad>, <fThk>, <tScale>, <iMod>}, <tRot>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tDst>: the distribution table used to populate the shape.
--	<tPar>: a table containing the following seven parameters:
--		<tGrp1>: a table containing the following four parameters:
--			<fA>: amplitude.
--			<fF>: frequency (degrees).
--			<fP>: phase (degrees).
--			<fD>: damping.
--		<fGrp2>: ditto.
--		<fGrp3>: ditto.
--		<fGrp4>: ditto.
--		<fGrp5>: ditto.
--		<tGrp6>: ditto.
--		<fTim>: the time parameter.
--		<fRad>: the radius of the curving tube.
--		<fThk>: the thickness of the tube as a percentage of the radius.
--		<tScale>: scale the entire shape by this much.
--		<iMod>: 0 = non-random, 1 = random.
--	<tRot>: a table containing the X, Y and Z Euler rotation angles, in degrees, for the entire object.
--	<tSeed>: the seed for the random number functions.
--------------------------------------------------------------------------------

function harmonographAdd(tPos, tDst, tPar, tRot, tSeed)
	local grp1, grp2, grp3, grp4, grp5, grp6 = tPar[1], tPar[2], tPar[3], tPar[4], tPar[5], tPar[6]
	local fTime, fRadius, fThick, tScale, iMod = rad(tPar[7]), tPar[8], tPar[9]/100, tPar[10], tPar[11]
	local A1, F1, P1, D1 = grp1[1], grp1[2], grp1[3], grp1[4]
	local A2, F2, P2, D2 = grp2[1], grp2[2], grp2[3], grp2[4]
	local A3, F3, P3, D3 = grp3[1], grp3[2], grp3[3], grp3[4]
	local A4, F4, P4, D4 = grp4[1], grp4[2], grp4[3], grp4[4]
	local A5, F5, P5, D5 = grp5[1], grp5[2], grp5[3], grp5[4]
	local A6, F6, P6, D6 = grp6[1], grp6[2], grp6[3], grp6[4]
	print
	(
		"\n{A1 = " .. A1 .. ",\tF1 = " .. F1 .. ",\tP1 = " .. P1 .. ",\tD1 = " .. D1 .. "}," ..
		"\n{A2 = " .. A2 .. ",\tF2 = " .. F2 .. ",\tP2 = " .. P2 .. ",\tD2 = " .. D2 .. "}," ..
		"\n{A3 = " .. A3 .. ",\tF3 = " .. F3 .. ",\tP3 = " .. P3 .. ",\tD3 = " .. D3 .. "}," ..
		"\n{A4 = " .. A4 .. ",\tF4 = " .. F4 .. ",\tP4 = " .. P4 .. ",\tD4 = " .. D4 .. "}," ..
		"\n{A5 = " .. A5 .. ",\tF5 = " .. F5 .. ",\tP5 = " .. P5 .. ",\tD5 = " .. D5 .. "}," ..
		"\n{A6 = " .. A6 .. ",\tF6 = " .. F6 .. ",\tP6 = " .. P6 .. ",\tD6 = " .. D6 .. "},"
	)
	for i, tTab in tDst do
		local jNum = tTab[1]
		local t, u, r = 0, 0, 0
		local tReg, uReg = 0, 0
		local tDif, uDif = fTime/jNum, 360/jNum
		for j = 1, jNum do
			if (iMod == 1) then
				t, u = srandomSet(tSeed,fTime,360)
				r = fRadius * fThick * sqrt(srandom(tSeed)) + fRadius * (1 - fThick)
			else
				t, u, r = tReg, uReg, fRadius
			end
			local tCirc =
			{
				r * cos(u),
				r * sin(u),
				0,
			}
			local tCoo = 
			{
				A1 * sin(deg(t) * F1 + P1) * exp(-D1 * t) + A2 * sin(deg(t) * F2 + P2) * exp(-D2 * t),
				A3 * sin(deg(t) * F3 + P3) * exp(-D3 * t) + A4 * sin(deg(t) * F4 + P4) * exp(-D4 * t),
				A5 * sin(deg(t) * F5 + P5) * exp(-D5 * t) + A6 * sin(deg(t) * F6 + P6) * exp(-D6 * t),
			}
			tCoo = vmultiplyV(tCoo, tScale)
			local tDerivatives =
			{
				A1 * -D1 * exp(-D1 * t) * sin(deg(t) * F1 + P1) + A1 * F1 * exp(-D1 * t) * cos(deg(t) * F1 + P1)	+ A2 * -D2 * exp(-D2 * t) * sin(deg(t) * F2 + P2) + A2 * F2 * exp(-D2 * t) * cos(deg(t) * F2 + P2),
				A3 * -D3 * exp(-D3 * t) * sin(deg(t) * F3 + P3) + A3 * F3 * exp(-D3 * t) * cos(deg(t) * F3 + P3)	+ A4 * -D4 * exp(-D4 * t) * sin(deg(t) * F4 + P4) + A4 * F4 * exp(-D4 * t) * cos(deg(t) * F4 + P4),
				A5 * -D5 * exp(-D5 * t) * sin(deg(t) * F5 + P5) + A5 * F5 * exp(-D5 * t) * cos(deg(t) * F5 + P5)	+ A6 * -D6 * exp(-D6 * t) * sin(deg(t) * F6 + P6) + A6 * F6 * exp(-D6 * t) * cos(deg(t) * F6 + P6),
			}
			tDerivatives = vmultiplyV(tDerivatives, tScale)
			local tNormedPos = vrotate(tCirc, vanglesXY(tDerivatives))
			tCoo = vaddV(tCoo, tNormedPos)
			tReg = tReg + tDif
			uReg = uReg + uDif
			appendShape(tPos, i, tTab, j, tCoo, tRot)
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		heightmapAdd
--  Description:	Creates a matrix of dots based on heightmap data.
--  Syntax:		heightmapAdd(<tPos>, <tRes>, {<tData>, <tScale>}, <tRot>, <xNil>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tRes>: a table containing the parameters of the outputted pebble or asteroid.
--	<tPar>: a table containing the following five parameters:
--		<tData>: the heightmap data in the form of a two-dimensional array.
--		<tScale>: the amount to scale the heightmap in the X, Y and Z directions.
--	<tRot>: a table containing the X, Y and Z Euler rotation angles, in degrees, for the entire object.
--	<xNil>: this should always remain "nil". It is ignored and used only to adhere to the API.
--  Notes:
--	1. I used the included "pgm_to_array_converter.html" tool to convert 
--	   from PGM to a Lua table. PGM images can be read and written using 
--	   the Windows freeware program XnView. Make sure to set the output to 
--	   ASCII in the XnView options.
--------------------------------------------------------------------------------

function heightmapAdd(tPos, tRes, tPar, tRot, xNil)
	local tData, tScale = tPar[1], tPar[2]
	local iLen = getn(tData)
	for i, iCount in tData do
		local jLen = getn(iCount)
		for j, jCount in iCount do
			local tCoo = {i - iLen/2, jCount, j - jLen/2}
			tCoo = vmultiplyV(tCoo, tScale)
			appendShape(tPos, i, tRes, j, tCoo, tRot)
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		strangeAdd
--  Description:	Creates a strange attractor, such as the Clifford or Lorenz attractors.
--			See for more info: http://www.aidansamuel.com/strange.php
--  Syntax:		strangeAdd(<tPos>, <tDst>, {<fA>, <fB>, <fC>, <fD>, <fScale>}, <tRot>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tDst>: the distribution table used to populate the shape.
--	<tPar>: a table containing the following five parameters:
--		<fA>: an arbitrary constant that partially determines the end result.
--		<fB>: ditto.
--		<fC>: ditto.
--		<fD>: ditto.
--		<fScale>: the rough size or scale of the curve.
--	<tRot>: a table containing the X, Y and Z Euler rotation angles, in degrees, for the entire object.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--	1. Would like the function to generate spirals with three or five arms instead of always just four.
--------------------------------------------------------------------------------

function strangeAdd(tPos, tDst, tPar, tRot, tSeed)
	local a, b, c, d, scale = tPar[1], tPar[2], tPar[3], tPar[4], tPar[5]
	print("{" .. a .. "," .. b .. "," .. c .. "," .. d .. "," .. scale .. ",}")
	local minBox = {0,0,0,}
	local maxBox = {0,0,0,}
	-- determine the bounding box so that you can then center the shape on the origin
	for i, tTab in tDst do
		local x, y, z = 0, 0, 0
		for j = 1, tTab[1] do
			local ptX = sin(deg(a * y)) - z * cos(deg(b * x))
			local ptY = z * sin(deg(c * x)) - cos(deg(d * y))
			local ptZ = sin(deg(x))
			if (i == 1) and (j == 1) then
				minBox = {ptX,ptY,ptZ,}
				maxBox = {ptX,ptY,ptZ,}
			else
				minBox = {min(minBox[1], ptX), min(minBox[2], ptY), min(minBox[3], ptZ),}
				maxBox = {max(maxBox[1], ptX), max(maxBox[2], ptY), max(maxBox[3], ptZ),}
			end
			x = ptX
			y = ptY
			z = ptZ
		end
	end
	local midBox = {(minBox[1] + maxBox[1])/2, (minBox[2] + maxBox[2])/2, (minBox[3] + maxBox[3])/2,}
	--print("minBox = " .. vstr(vmultiply(minBox, scale)))
	--print("maxBox = " .. vstr(vmultiply(maxBox, scale)))
	print("midBox = " .. vstr(vmultiply(midBox, scale)))
	for i, tTab in tDst do
		local x, y, z = 0, 0, 0
		for j = 1, tTab[1] do
			local ptX = sin(deg(a * y)) - z * cos(deg(b * x))
			local ptY = z * sin(deg(c * x)) - cos(deg(d * y))
			local ptZ = sin(deg(x))
			local tCoo = 
			{
				(ptX - midBox[1]) * scale,
				(ptY - midBox[2]) * scale,
				(ptZ - midBox[3]) * scale,
			}
			--print("tCoo = " .. vstr(tCoo))
			appendShape(tPos, i, tTab, j, tCoo, tRot)
			x = ptX
			y = ptY
			z = ptZ
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		spiralAdd
--  Description:	Creates a spiral.
--  Syntax:		spiralAdd(<tPos>, <tDst>, {<sLay>, <fRad>, <iArm>, <fRot>, <fAng>, <fHgh>, <fWid>, <fThk>, <tTim>, <iMod>,}, <tRot>, <tSeed>)
--  Arguments:
--	<tPos>: a table containing the shape's center coordinates.
--	<tDst>: the distribution table used to populate the shape.
--	<tPar>: a table containing the following ten parameters:
--		<sLay>: may be either "Nautilus" or "Archimedes".
--		<fRad>: depending on <fAng>, this is either the minimum or maximum radius of the spiral.
--		<iArm>: the number of arms the spiral will have.
--		<fRot>: the number of times the spiral will rotate around the origin.
--		<fAng>: the angle (degrees) of deviation (90' and 270' make a circle).
--		<fHgh>: the height of the spiral above the plane.
--		<fWid>: the width of the spiral arms.
--		<fThk>: the thickness of the spiral arms.
--		<tTim>: a table containing the minimum and maximum values for "t" (time) at which the curve is sampled. (must be a float between 0 and 1)
--		<iMod>: 0 is non-random, 1 is random, 2 is random-mode with tapering width.
--	<tRot>: a table containing the X, Y and Z rotation angles (degrees) for the entire object.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--	1. Would be nice to also have tubular cross-sections instead of only rectangular.
--------------------------------------------------------------------------------

function spiralAdd(tPos, tDst, tPar, tRot, tSeed)
	local sLay, nRad, nArm, nRot, nAng, nHgh, nWid, nThk, tTim, iMod = tPar[1], tPar[2], tPar[3], tPar[4], tPar[5], tPar[6], tPar[7], tPar[8], tPar[9], tPar[10]
	local minTim, maxTim, v, t, s, l, w, h = tTim[1], tTim[2], 360 * nRot, 0, 0, 0, 0, 0
	local rotArm = 0
	local divArm = (360/nArm)
	for k = 1, nArm do
		for i, tTab in tDst do
			local t_X, l_X, w_X, h_X = minTim, nWid/-2, nWid/-2, nThk/-2
			local iNum = tTab[1]
			for j = 1, iNum do
				local tCoo = {}
				if (iMod == 1) then
					v, t = v, srandom3(tSeed, minTim, maxTim)
					s = t
					if (sLay == "Archimedes") then
					--	s = 1 - t
					end
					l, w, h = srandom3(tSeed, nWid) - nWid/2, srandom3(tSeed, nWid) - nWid/2, srandom3(tSeed, nThk) - nThk/2
				elseif (iMod == 2) then
					v, t = v, srandom3(tSeed, minTim, maxTim)
					s = t
					if (sLay == "Archimedes") then
					--	s = 1 - t
					end
					l, w, h = srandom3(tSeed, 0, nWid * s), srandom3(tSeed, 0, nWid * s), srandom3(tSeed, nThk) - nThk/2
				elseif (iMod == 0) then
					v, t = v, t_X
					l, w, h = l_X, w_X, h_X
					t_X = t_X + (maxTim - minTim)/iNum
					l_X, w_X, h_X = l_X + nWid/iNum, w_X + nWid/iNum, h_X + nThk/iNum
				end
				if (sLay == "Nautilus") then
					tCoo =
					{
						exp(rad(v * t)/tan(nAng)) * cos(v * t) * nRad + l,
						h - nHgh * t + nHgh/2,
						exp(rad(v * t)/tan(nAng)) * sin(v * t) * nRad + w,
					}
				elseif (sLay == "Archimedes") then
					tCoo =
					{
						cos(v * t) * t * nRad + l,
						h + nHgh * t - nHgh/2,
						sin(v * t) * t * nRad + w,
					}
				end
				appendShape(tPos, i, tTab, j, vrotate(tCoo, {0,rotArm,0,}), tRot)
			end
		end
		rotArm = rotArm + divArm
	end
end


--------------------------------------------------------------------------------
--  Name:		stitchAdd
--  Description:	Generates a triangle made of crosshatched line segments, like in the art of curvestitching.
--  Syntax:		stitchAdd(<tPos>, <tRes>, {<tPtA>, <tPtB>, <tPtC>, <iNum>, <bAll>, <bCorners>}, <tRot>, <xNil>)
--  Inputs:
--	<tPos>: the center of the shape.
--	<tRes>: a table containing the parameters of the outputted pebble or asteroid.
--	<tPar>: a table containing the following parameters:
--		<tPtA>: a table containing the X, Y and Z coordinates of a point on the triangle.
--		<tPtB>: a table containing the X, Y and Z coordinates of a point on the triangle.
--		<tPtC>: a table containing the X, Y and Z coordinates of the center point on the triangle.
--		<iNum>: the number of line segments to generate.
--		<bAll>: turn this off to generate only the points on the spline defined by the line segments.
--		<bCorners>: enables/disables generation of points at the corners of the triangle to prevent duplicate overlapping asteroids.
--	<tRot>: a table containing the X, Y and Z rotation angles (degrees) for the entire object.
--	<xNil>: this should always remain "nil". It is ignored and used only to adhere to the API.
--  Notes:
--	1. Not sure I completely fixed the overlapping objects at the cornes and edges.
--------------------------------------------------------------------------------

function stitchAdd(tPos, tRes, tPar, tRot, xNil)
	local Point_A, Point_B, Point_C = tPar[1], tPar[2], tPar[3]
	local n, All, Corners = tPar[4], tPar[5], tPar[6]
	local iCount = 0
	if (All == 1) then
		local Start = 1
		local End = n - 1
		if (Corners == 1) then
			Start = 0
			End = n
		end
		for i = Start, End do
			for j = Corners and 0 or 1, Corners and n or n - 1 do
				local tCoo =
				{
					i * j/n^2 * Point_A[1] + (n - i) * (n - j)/n^2 * Point_C[1] + (i * (n - j) + j * (n - i))/n^2 * Point_B[1],
					i * j/n^2 * Point_A[2] + (n - i) * (n - j)/n^2 * Point_C[2] + (i * (n - j) + j * (n - i))/n^2 * Point_B[2],
					i * j/n^2 * Point_A[3] + (n - i) * (n - j)/n^2 * Point_C[3] + (i * (n - j) + j * (n - i))/n^2 * Point_B[3],
				}
				iCount = iCount + 1
				appendShape(tPos, 1, tRes, iCount, tCoo, tRot)
			end
		end
	else
		local Start = 1/n
		local End = (1 - 1/n)
		if (Corners == 1) then
			Start = 0
			End = 1
		end
		for i = Start, End, 1/n do
			local tCoo =
			{
				(1 - i)^2 * Point_A[1] + 2 * (1 - i) * i * Point_C[1] + i^2 * Point_B[1],
				(1 - i)^2 * Point_A[2] + 2 * (1 - i) * i * Point_C[2] + i^2 * Point_B[2],
				(1 - i)^2 * Point_A[3] + 2 * (1 - i) * i * Point_C[3] + i^2 * Point_B[3],
			}
			iCount = iCount + 1
			appendShape(tPos, 1, tRes, iCount, tCoo, tRot)
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		literalAdd
--  Description:	Adds the contents of a distribution table to the map without changing any values.
--  Syntax:		literalAdd(<tDst>)
--  Arguments:
--	<tDst>: the distribution table used to populate the shape.
--------------------------------------------------------------------------------

function literalAdd(tDst)
	for i, tTab in tDst do
		for j = 1, tTab[1] do
			appendShape({0, 0, 0,}, i, tTab, j, {0, 0, 0,}, {0, 0, 0,})
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		easyPatch
--  Description:	Creates a resource patch with minimal effort.
--  Syntax:		easyPatch(<tPos>, <fRUs>, <tSeed>)
--  Arguments:
--	<tPos>: the shape's center coordinates.
--	<fRUs>: the percent of the default RU to retain.
--	<tSeed>: the seed for the random number functions.
--  Notes:
--	1. Need to consider once again whether <fRUs> and <tSeed> should be optional.
--------------------------------------------------------------------------------

function easyPatch(tPos, fRUs, tSeed)
	if not (fRUs) then
		fRUs = 100
	end
	if not (tSeed) then
		tSeed = {seed = 977322}
	end
	local tCoo = {}
	-- asteroid_type = {amount, inner radius, outer radius,}
	local easyPatchDist = {Asteroid_4 = {1, 0, 0,}, Asteroid_3 = {4, 400, 800,}, Asteroid_2 = {5, 800, 1600,},}
	for k, tTab in easyPatchDist do
		for j = 1, tTab[1] do
			local r = srandom3(tSeed, tTab[2], tTab[3])
			local v, u = srandomSet(tSeed, 180,360)
			tCoo =
			{
				tPos[1] + sqrt(r^2 - (r * cos(v))^2) * cos(u),
				tPos[2] + r * cos(v),
				tPos[3] + sqrt(r^2 - (r * cos(v))^2) * sin(u),
			}
			addAsteroid(k, tCoo, fRUs, 0, 0, 0, 0)
		end
	end
end


--------------------------------------------------------------------------------
--  Name:		randomMusic
--  Description:	Randomly selects the level music.
--  Syntax:		randomMusic(<tSeed>, <iMod>, <tTab>, <sDir>)
--  Arguments:
--	<tSeed>: the seed for the random number functions.
--	<iMod>: may be 0, 1, 2, 3, 4 or 5.
--	If <iMod> is 0, then this function is disabled.
--	If <iMod> is 1, then the level music is selected from only the ambient tracks.
--	If <iMod> is 2, then the level music is selected from only the battle tracks.
--	If <iMod> is 3, then the level music is selected from both the ambient and battle tracks.
--	If <iMod> is 4, then the level music is selected from only <tTab>.
--	If <iMod> is 5, then the level music is selected from all of the above.
--	<tTab>: (optional) a table containing the names of the custom audio tracks. (table)
--	<sDir>: (optional) the directory where the extra files can be found. Must have a trailing slash. (string)
--  Notes:
--	1. This function must be called from within the "NonDetermChunk" 
--	   portion of a ".level" file.
--	2. Since it is a NonDetermChunk function, it does not need to be seeded 
--	   manually in order to avoid desyncs (I think).
--------------------------------------------------------------------------------

function randomMusic(tSeed, iMod, tTab, sDir)
	local iTot = 23
	local iLen = 0
	if (tTab) then
		iLen = getn(tTab)
		iTot = iTot + iLen
	end
	local ranNum, musDir, musTrk = 0, "", ""
	local musTab =
	{
		"amb_01", "amb_02", "amb_03", "amb_04", "amb_05", "amb_06", "amb_07", "amb_08", "amb_09", "amb_10", "amb_11", "amb_12", "amb_13", "amb_14",
		"battle_01", "battle_04", "battle_04_alt", "battle_06", "battle_keeper", "battle_movers", "battle_planetkillers", "battle_sajuuk", "bentus_arrival",
	}
	if ((iMod == 4) or (iMod == 5)) then
		for k = 1, iLen do
			musTab[k + 23] = tTab[k]
		end
	end
	if (iMod == 1) then
		ranNum = srandom(tSeed, 1, 14)
	elseif (iMod == 2) then
		ranNum = srandom(tSeed, 15, 23)
	elseif (iMod == 3) then
		ranNum = srandom(tSeed, 1, 23)
	elseif (iMod == 4) then
		ranNum = srandom(tSeed, 24, 23 + iLen)
	elseif (iMod == 5) then
		ranNum = srandom(tSeed, 1, 23 + iLen)
	end
	if (ranNum <= 14) then
		musDir = "data:sound\\music\\ambient\\"
	elseif (ranNum <= 23) then
		musDir = "data:sound\\music\\battle\\"
	elseif (ranNum <= (23 + iLen)) then
		musDir = sDir
	end
	if (iMod ~= 0) then
		setDefaultMusic(musDir .. musTab[ranNum])
		print("Level music: \"" .. musTab[ranNum] .. "\" (" .. ranNum .. "/" .. iTot .. ")")
	end
end


--------------------------------------------------------------------------------
--  Name:		randomBackground
--  Description:	Randomly selects the level background.
--  Syntax:		randomBackground(<tSeed>, <iMod>, <tTab>)
--  Arguments:
--	<tSeed>: the seed for the random number functions.
--	<iMod>: may be 0, 1, 2, 3, 4 or 5.
--	If <iMod> is 0, then this function has been disabled.
--	If <iMod> is 1, then the level background is selected from only the mission backgrounds.
--	If <iMod> is 2, then the level background is selected from only the other backgrounds.
--	If <iMod> is 3, then the level background is selected from both the mission and other backgrounds.
--	If <iMod> is 4, then the level background is selected from only <tTab>.
--	If <iMod> is 5, then the level background is selected from all of the above.
--	<tTab>: (optional) a table containing the names of the custom backgrounds.
--  Notes:
--	1. This function must be called from within the "NonDetermChunk" 
--	   portion of a ".level" file.
--	2. Since it is a NonDetermChunk function, it does not need to be seeded 
--         manually in order to avoid desyncs (I think).
--------------------------------------------------------------------------------

function randomBackground(tSeed, iMod, tTab)
	local iTot = 22
	local iLen = 0
	if (tTab) then
		iLen = getn(tTab)
		iTot = iTot + iLen
	end
	local ranNum = 0
	local backgroundTable =
	{
		"m01", "m02", "m03", "m04", "m05", "m06", "m07", "m08", "m09", "m10", "m11", "m12", "m13", "m14", "m15",
		"planet", "quick", "singlesun", "tanis", "taniswstars", "black", "white",
	}
	if ((iMod == 4) or (iMod == 5)) then
		for k = 1, iLen do
			backgroundTable[k + 22] = tTab[k]
		end
	end
	if (iMod == 1) then
		ranNum = srandom(tSeed, 1, 15)
	elseif (iMod == 2) then
		ranNum = srandom(tSeed, 16, 22)
	elseif (iMod == 3) then
		ranNum = srandom(tSeed, 1, 22)
	elseif (iMod == 4) then
		ranNum = srandom(tSeed, 23, 22 + iLen)
	elseif (iMod == 5) then
		ranNum = srandom(tSeed, 1, 23 + iLen)
	end
	if (iMod ~= 0) then
		loadBackground(backgroundTable[ranNum])
		print("Level background: \"" .. backgroundTable[ranNum] .. "\" (" .. ranNum .. "/" .. iTot .. ")")
	end
end


--------------------------------------------------------------------------------
-- Random number functions.
--

-- Randomly returns either 1 or -1.
function randomSign()
	if (random() > 0.5) then
		return 1
	else
		return -1
	end
end

-- Randomly returns either 1 or 0.
function randomBit()
	if (random() > 0.5) then
		return 1
	else
		return 0
	end
end

-- Works just like random(), but can accept zero as an argument.
function random2(fVal1, fVal2)
	if (fVal2) then
		if ((fVal2 - fVal1) == 0) then
			return fVal2
		else
			return random(fVal1, fVal2)
		end
	elseif (fVal1) then
		if (fVal1 == 0) then
			return 0
		else
			return random(fVal1)
		end
	else
		return random()
	end
end

-- Works just like random(), but can accept zero as an argument and always returns a float value, not an integer.
function random3(fVal1, fVal2)
	if (fVal2) then
		return fVal1 + random() * (fVal2 - fVal1)
	elseif (fVal1) then
		return random() * fVal1
	else
		return random()
	end
end

-- For each argument, returns a random float value between 0 and the argument.
function randomSet(...)
	local v = {}
	for i = 1, getn(arg) do
		v[i] = random3(arg[i])
	end
	if arg[5] then
		return v[1], v[2], v[3], v[4], v[5]
	elseif arg[4] then
		return v[1], v[2], v[3], v[4]
	elseif arg[3] then
		return v[1], v[2], v[3]
	elseif arg[2] then
		return v[1], v[2]
	elseif arg[1] then
		return v[1]
	end
end

-- For every two arguments, returns a random float value between the former argument and the latter argument.
function randomSet2(...)
	local v = {}
	for i = 2, getn(arg), 2 do
		v[i/2] = random3(arg[i-1], arg[i])
	end
	if arg[10] then
		return v[1], v[2], v[3], v[4], v[5]
	elseif arg[8] then
		return v[1], v[2], v[3], v[4]
	elseif arg[6] then
		return v[1], v[2], v[3]
	elseif arg[4] then
		return v[1], v[2]
	elseif arg[2] then
		return v[1]
	end
end

-- rough adaptation of Knuth float generator
-- Note: seedobj must be a table with a field named `seed`;
-- this field must be negative; after the first number has
-- been generated, the seedobj table will be populated with
-- additional state needed to generate numbers; changing its
-- `seed` field to a negative number will reinitialize the
-- generator and start a new pseudorandom sequence.
function srandom( seedobj, fVal1, fVal2 )
	local B =  4000000
	local ma = seedobj.ma
	local seed = seedobj.seed
	local mj, mk
	if seed < 0 or not ma then
		ma = {}
		seedobj.ma = ma
		mj = abs( 1618033 - abs( seed ) )
		mj = mod( mj, B )
		ma[55] = mj
		mk = 1
		for i = 1, 54 do
			local ii = mod( 21 * i,  55 )
			ma[ii] = mk
			mk = mj - mk
			if mk < 0 then
				mk = mk + B
			end
			mj = ma[ii]
		end
		for k = 1, 4 do
			for i = 1, 55 do
				ma[i] = ma[i] - ma[ 1 + mod( i + 30,  55) ]
				if ma[i] < 0 then
					ma[i] = ma[i] + B
				end
			end
		end
		seedobj.inext = 0
		seedobj.inextp = 31
		seedobj.seed = 1
	end -- if
	local inext = seedobj.inext
	local inextp = seedobj.inextp
	inext = inext + 1
	if inext == 56 then
		inext = 1
	end
	seedobj.inext = inext
	inextp = inextp + 1
	if inextp == 56 then
		inextp = 1
	end
	seedobj.inextp = inextp
	mj = ma[ inext ] - ma[ inextp ]
	if mj < 0 then
		mj = mj + B
	end
	ma[ inext ] = mj
	local temp_rand = mj / B
	if fVal2 then
		return floor( fVal1 + 0.5 + temp_rand * ( fVal2 - fVal1 ) )
	elseif fVal1 then
		return floor( temp_rand * fVal1 ) + 1
	else
		return temp_rand
	end
end


-- Randomly returns either 1 or -1. Seeded.
function srandomSign(seedobj)
	if (srandom(seedobj) > 0.5) then
		return 1
	else
		return -1
	end
end

-- Randomly returns either 1 or 0. Seeded.
function srandomBit(seedobj)
	if (srandom(seedobj) > 0.5) then
		return 1
	else
		return 0
	end
end

-- Works just like random(), but can accept zero as an argument. Seeded.
function srandom2(seedobj, fVal1, fVal2)
	if (fVal2) then
		if ((fVal2 - fVal1) == 0) then
			return fVal2
		else
			return srandom(seedobj, fVal1, fVal2)
		end
	elseif (fVal1) then
		if (fVal1 == 0) then
			return 0
		else
			return srandom(seedobj, fVal1)
		end
	else
		return srandom(seedobj)
	end
end

-- Works just like random(), but can accept zero as an argument and always returns a float value, not an integer. Seeded.
function srandom3(seedobj, fVal1, fVal2)
	if (fVal2) then
		return fVal1 + srandom(seedobj) * (fVal2 - fVal1)
	elseif (fVal1) then
		return srandom(seedobj) * fVal1
	else
		return srandom(seedobj)
	end
end

-- For each argument, returns a random float value between 0 and the argument. Seeded.
function srandomSet(seedobj, ...)
	local v = {}
	for i = 1, getn(arg) do
		v[i] = srandom3(seedobj, arg[i])
	end
	if arg[5] then
		return v[1], v[2], v[3], v[4], v[5]
	elseif arg[4] then
		return v[1], v[2], v[3], v[4]
	elseif arg[3] then
		return v[1], v[2], v[3]
	elseif arg[2] then
		return v[1], v[2]
	elseif arg[1] then
		return v[1]
	end
end

-- For every two arguments, returns a random float value between the former argument and the latter argument. Seeded.
function srandomSet2(seedobj, ...)
	local v = {}
	for i = 2, getn(arg), 2 do
		v[i/2] = srandom3(seedobj, arg[i-1], arg[i])
	end
	if arg[10] then
		return v[1], v[2], v[3], v[4], v[5]
	elseif arg[8] then
		return v[1], v[2], v[3], v[4]
	elseif arg[6] then
		return v[1], v[2], v[3]
	elseif arg[4] then
		return v[1], v[2]
	elseif arg[2] then
		return v[1]
	end
end

-- Returns a vector with random components.
function vrand(tVecIn)
	local tVecOut = {}
	for i = 1, getn(tVecIn) do
		tinsert(tVecOut, random(tVecIn[i]))
	end
	return tVecOut
end

-- Returns a vector with random components. Seeded.
function svrand(seedobj, tVecIn)
	local tVecOut = {}
	for i = 1, getn(tVecIn) do
		tinsert(tVecOut, srandom(seedobj, tVecIn[i]))
	end
	return tVecOut
end

-- Returns a vector with random components.
function vrand2(tVecIn)
	local tVecOut = {}
	for i = 1, getn(tVecIn) do
		tinsert(tVecOut, random2(tVecIn[i][1], tVecIn[i][2]))
	end
	return tVecOut
end

-- Returns a vector with random components. Seeded.
function svrand2(seedobj, tVecIn)
	local tVecOut = {}
	for i = 1, getn(tVecIn) do
		tinsert(tVecOut, srandom2(seedobj, tVecIn[i][1], tVecIn[i][2]))
	end
	return tVecOut
end

-- Returns a vector with random components.
function vrand3(tVecIn)
	local tVecOut = {}
	for i = 1, getn(tVecIn) do
		tinsert(tVecOut, random3(tVecIn[i][1], tVecIn[i][2]))
	end
	return tVecOut
end

-- Returns a vector with random components. Seeded.
function svrand3(seedobj, tVecIn)
	local tVecOut = {}
	for i = 1, getn(tVecIn) do
		tinsert(tVecOut, srandom3(seedobj, tVecIn[i][1], tVecIn[i][2]))
	end
	return tVecOut
end

--------------------------------------------------------------------------------
-- Some trigonometric functions.
--

-- Returns the hyperbolic cosine of an angle.
function cosh(fAng)
	return (exp(fAng) + exp(-fAng))/2
end


-- Returns the hyperbolic sine of an angle.
function sinh(fAng)
	return (exp(fAng) - exp(-fAng))/2
end


-- Returns the hyperbolic tangent of an angle.
function tanh(fAng)
	return (exp(fAng) - exp(-fAng))/(exp(fAng) + exp(-fAng))
end


-- Returns the hyperbolic cosecant of an angle.
function csch(fAng)
	return 1/sinh(fAng)
end


-- Returns the hyperbolic secant of an angle.
function sech(fAng)
	return 1/cosh(fAng)
end


-- Returns the hyperbolic cotangent of an angle.
function coth(fAng)
	return 1/tanh(fAng)
end


-- Returns the cosecant of an angle.
function csc(fAng)
	return 1/sin(fAng)
end


-- Returns the secant of an angle.
function sec(fAng)
	return 1/cos(fAng)
end


-- Returns the cotangent of an angle.
function cot(fAng)
	return 1/tan(fAng)
end


-- Returns the exsecant of an angle.
function exsec(fAng)
	return sec(fAng) - 1
end


-- Returns the coexsecant of an angle.
function coexsec(fAng)
	return csc(fAng) - 1
end


-- Returns the versesine of an angle.
function vers(fAng)
	return 1 - cos(fAng)
end


-- Returns the coversesine of an angle.
function covers(fAng)
	return 1 - sin(fAng)
end


-- Returns the half-versesine of an angle.
function hav(fAng)
	return vers(fAng)/2
end


--------------------------------------------------------------------------------
-- Some miscellaneous mathematical functions.
--

-- Rounds a number to the nearest integer.
function round(fVal)
	return floor(fVal + 0.5)
end

-- Some programming languages need this
function pow(fA, fB)
	return fA^fB
end


--------------------------------------------------------------------------------
-- Some vector functions.
--

-- Returns the normalized form of a vector.
function vnormalize(tVec)
	return vdivide(tVec, vlength(tVec))
end

-- Returns the length of a vector.
function vlength(tVec)
	return sqrt(vsum(vpower(tVec, 2)))
end

-- Returns the distance between two vectors.
function vdistance(tVec1, tVec2)
	return vlength(vsubtractV(tVec2, tVec1))
end

-- Returns the dot product of two vectors.
function vdot(tVec1, tVec2)
	return vsum(vmultiplyV(tVec1, tVec2))
end

-- Returns the angle between two vectors.
function vangle(tVec1, tVec2)
	return acos(vdot(vnormalize(tVec1), vnormalize(tVec2)))
end

-- Returns the cross product of two vectors as a new vector.
function vcross(tVec1, tVec2)
	return
	{
		tVec1[2] * tVec2[3] - tVec1[3] * tVec2[2],
		tVec1[3] * tVec2[1] - tVec1[1] * tVec2[3],
		tVec1[1] * tVec2[2] - tVec1[2] * tVec2[1],
	}
end

-- tests whether two vectors are equal
function veq(tVec1, tVec2)
	if (tVec1[1] == tVec2[1]) and (tVec1[2] == tVec2[2]) and (tVec1[3] == tVec2[3]) then
		return 1
	else
		return 0
	end
end

-- returns the midpoint of two points as a new point
function vmidpoint(tVec1, tVec2)
	return
	{
		(tVec1[1] + tVec2[1]) / 2,
		(tVec1[2] + tVec2[2]) / 2,
		(tVec1[3] + tVec2[3]) / 2,
	}
end

-- Adds an amount to each vector component, then returns the resulting vector.
function vadd(tVec, fVal)
	local tmpVec = {}
	for i, tTab in tVec do
		tmpVec[i] = tVec[i] + fVal
	end
	return tmpVec
end

-- Adds the components of the second vector to the components of the first vector, then returns the resulting vector.
function vaddV(tVec1, tVec2)
	local tmpVec = {}
	for i, tTab in tVec2 do
		tmpVec[i] = tVec1[i] + tTab
	end
	return tmpVec
end

-- Subtracts an amount from each vector component, then returns the resulting vector.
function vsubtract(tVec, fVal)
	local tmpVec = {}
	for i, tTab in tVec do
		tmpVec[i] = tVec[i] - fVal
	end
	return tmpVec
end

-- Subtracts the components of the second vector from the components of the first vector, then returns the resulting vector.
function vsubtractV(tVec1, tVec2)
	local tmpVec = {}
	for i, tTab in tVec2 do
		tmpVec[i] = tVec1[i] - tTab
	end
	return tmpVec
end

-- Multiplies each vector component by some amount, then returns the resulting vector.
function vmultiply(tVec, fVal)
	local tmpVec = {}
	for i, tTab in tVec do
		tmpVec[i] = tTab * fVal
	end
	return tmpVec
end

-- Multiplies the components of the first vector by the components of the second vector, then returns the resulting vector.
function vmultiplyV(tVec1, tVec2)
	local tmpVec = {}
	for i, tTab in tVec2 do
		tmpVec[i] = tVec1[i] * tTab
	end
	return tmpVec
end

-- Divides each vector component by some amount, then returns the resulting vector.
function vdivide(tVec, fVal)
	local tmpVec = {}
	for i, tTab in tVec do
		tmpVec[i] = tTab/fVal
	end
	return tmpVec
end

-- Divides the components of the first vector by the components of the second vector, then returns the resulting vector.
function vdivideV(tVec1, tVec2)
	local tmpVec = {}
	for i, tTab in tVec2 do
		tmpVec[i] = tVec1[i]/tTab
	end
	return tmpVec
end

-- Raises each vector component to the some power, then returns the new vector.
function vpower(tVec, fVal)
	local tmpVec = {}
	for i, tTab in tVec do
		tmpVec[i] = tTab^fVal
	end
	return tmpVec
end

-- Raises the components of the first vector to the power specified by the components the second vector, then returns the new vector.
function vpowerV(tVec1, tVec2)
	local tmpVec = {}
	for i, tTab in tVec2 do
		tmpVec[i] = tVec1[i]^tTab
	end
	return tmpVec
end

-- Returns the sum of all the vector's components.
function vsum(tVec1)
	local tmpVal = 0
	for i, tTab in tVec1 do
		tmpVal = tmpVal + tTab
	end
	return tmpVal
end

-- Returns a vector converted into a string.
function vstr(tVec)
	local tmpStr = "{"
	for i, tTab in tVec do
		tmpStr = tmpStr .. tTab .. ", "
	end
	tmpStr = tmpStr .. "}\n"
	return tmpStr
end

-- Rotates a vector around the origin by the specified Euler angles, then returns the resulting vector.
-- Rotates around the Z-axis first, followed by the X-axis and the Y-axis.
function vrotate(tVec, tAng)
	tVec =
	{
		tVec[1] * cos(tAng[3]) - tVec[2] * sin(tAng[3]),
		tVec[1] * sin(tAng[3]) + tVec[2] * cos(tAng[3]),
		tVec[3],
	}
	tVec =
	{
		tVec[1],
		tVec[2] * cos(tAng[1]) - tVec[3] * sin(tAng[1]),
		tVec[2] * sin(tAng[1]) + tVec[3] * cos(tAng[1]),
	}
	tVec =
	{
		tVec[1] * cos(tAng[2]) + tVec[3] * sin(tAng[2]),
		tVec[2],
		-1 * tVec[1] * sin(tAng[2]) + tVec[3] * cos(tAng[2]),
	}
	return tVec
end

-- Returns an array containing the vector's Euler angles, relative to the Z-axis.
-- To reproduce the original vector, rotate a point on the Z-axis by these angles.
function vanglesXY(tVec2)
	local fSgnX, fSgnY, tPrjB1 = 1, 1, vnormalize({tVec2[1], 0, tVec2[3],})
	if (tPrjB1[1] ~= 0) then
		fSgnX = tPrjB1[1]/abs(tPrjB1[1]) * -1
	end
	local fAngY = acos(tPrjB1[3]) * fSgnX
	local tPrjB2 = vnormalize(vrotate(tVec2, {0, fAngY, 0,}))
	if (tPrjB2[2] ~= 0) then
		fSgnY = tPrjB2[2]/abs(tPrjB2[2])
	end
	local fAngX = acos(tPrjB2[3]) * fSgnY
	return {fAngX * -1, fAngY * -1, 0,}
end

-- Rotates the first vector around the second vector by some amount, then returns the resulting vector.
function vaxis_rotate(tVec1, tVec2, fAngZ)
	local tAng = vanglesXY(tVec2)
	return vrotate(vrotate(vrotate(vrotate(tVec1, {0, tAng[2], 0,}), {tAng[1], 0, 0,}), {0, 0, fAngZ,}), vmultiply(tAng, -1))
end


--------------------------------------------------------------------------------
-- Some table manipulation functions.
--

--------------------------------------------------------------------------------
-- Returns the length of a table. Useful where the 'getn' function is normally unavailable.
if not getn then
	function getn(tTable)
		local nCount = 0
		for i, iCount in tTable do
			if i ~= "n" then
				nCount = nCount + 1
			end
		end
		return nCount
	end
end


--------------------------------------------------------------------------------
-- Inserts an item into a table. Useful where the 'tinsert' function is normally unavailable.
if not tinsert then
	function tinsert(tTable, Arg1, Arg2)
		if (Arg2) then
			local TempTable = {}
			for i = Arg1, getn(tTable) do
				TempTable[i + 1] = tTable[i]
			end
			for i = Arg1, getn(tTable) do
				tTable[i + 1] = TempTable[i + 1]
			end
			tTable[Arg1] = Arg2
		else
			tTable[getn(tTable) + 1] = Arg1
		end
	end
end


--------------------------------------------------------------------------------
-- Compares two tables and returns true if they're equal and false if they're not.
function tcomp(tTable1, tTable2)
	local same = 1
	if (getn(tTable1) ~= getn(tTable2)) then
		same = 0
	else
		for i, k in tTable1 do
			if (type(tTable1[i]) == "table") and (type(tTable2[i]) == "table") then
				same = tcomp(tTable1[i], tTable2[i])
				if (same == 0) then
					break
				end
			elseif (tTable1[i] ~= tTable2[i]) then
				same = 0
				break
			end
		end
	end
	return same
end


--------------------------------------------------------------------------------
-- Mathematical shape functions
--

function makeCuboid(tPar, tSeed)
	local t, p = srandom(tSeed), srandomSign(tSeed)
	local l, w, h, L, W, H = srandomSet2(tSeed, -tPar[2], tPar[2], -tPar[3], tPar[3], -tPar[4], tPar[4], tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], tPar[4] - tPar[5], tPar[4])
	if (t < 1/3) then
		l = L * p
	elseif (t < 2/3) then
		w = W * p
	elseif (t <= 1) then
		h = H * p
	end
	return {l, h, w,}
end

function makeEllipsoid(tPar, tSeed)
	local L, W, H = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], tPar[4] - tPar[5], tPar[4])
	local u, v = srandomSet(tSeed, 180, 360)
	return {L * cos(v) * sin(u), H * sin(v) * sin(u), W * cos(u),}
end

function makeCylinder(tPar, tSeed)
	local L, W, h = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], -tPar[4], tPar[4])
	local u, v = srandomSet(tSeed, 180, 360)
	return {L * cos(v), h, W * sin(v),}
end

function makeCone(tPar, tSeed)
	local L, W, h = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], -tPar[4], tPar[4])
	local v = srandom3(tSeed, 360)
	return {(1 - h/c) * L * cos(v)/2, h, (1 - h/c) * W * sin(v)/2,}
end

function makeToroid(tPar, tSeed)
	local H, M = srandomSet2(tSeed, tPar[4] - tPar[5], tPar[4], tPar[6] - tPar[5], tPar[6])
	local v, o = srandomSet(tSeed, 360, 360)
	return {(tPar[2] + M * cos(v)) * cos(o), H * sin(v), (tPar[3] + M * cos(v)) * sin(o),}
end

function makeHelicoid(tPar, tSeed)
	local L, W = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3])
	local t = srandom(tSeed)
	return {L * cos(t * tPar[6] * 360), tPar[4] * (2 * t - 1), W * sin(t * tPar[6] *  360),}
end

function makeParaboloid(tPar, tSeed)
	local L, W, h = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], -tPar[4], tPar[4])
	local v = srandom3(tSeed, 360)
	return {L * sqrt(h/1000) * cos(v), h, W * sqrt(h/1000) * sin(v),}
end

function makeHyperboloid(tPar, tSeed)
	local L, W, H = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], tPar[4] - tPar[5], tPar[4])
	local t, v, p = srandom(tSeed), srandom3(tSeed, 360), srandomSign(tSeed)
	return {L * sqrt(1 + (t * p)^2) * cos(v), H * (t * p), W * sqrt(1 + (t * p)^2) * sin(v),}
end

function makeAstroid(tPar, tSeed)
	local L, W, H = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], tPar[4] - tPar[5], tPar[4])
	local v, o = srandomSet(tSeed, 360, 360)
	return {L * (cos(o) * cos(v))^3, H * (sin(v))^3, W * (sin(o) * cos(v))^3,}
end

function makeFunnel(tPar, tSeed)
	local L, W, H = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], tPar[4] - tPar[5], tPar[4])
	local t, v = srandom(tSeed), srandom3(tSeed, 360)
	return {L * t * cos(v), H * log(t)/10, W * t * sin(v),}
end

function makeDini(tPar, tSeed)
	local L, W, H = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], tPar[4] - tPar[5], tPar[4])
	local v, u = srandomSet(tSeed, 360, 180)
	return {L * (cos(tPar[6] * v) * sin(u/2)), H * (cos(u/2) + log(tan(u/4)) + rad(tPar[6] * v)/(2 * PI)), W * (sin(tPar[6] * v) * sin(u/2)),}
end

function makeCorkscrew(tPar, tSeed)
	local L, W, H = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], tPar[4] - tPar[5], tPar[4])
	local v, u = srandomSet(tSeed, 360, 180)
	return {L * cos(v) * cos(u), H * rad(v)/(2 * PI), W * sin(v) * cos(u),}
end

function makeSeashell(tPar, tSeed)
	local t, o = srandom(tSeed), srandom3(tSeed, 360)
	return
	{
		(tPar[5]/tPar[6] + (1 - t) * (1 + cos(o))) * tPar[2] * cos(tPar[6] * t * 360),
		tPar[4] * t^(1/2) * (2 * tPar[6] - 1) + tPar[3] * sin(o) * (1 - t),
		(tPar[5]/tPar[6] + (1 - t) * (1 + cos(o))) * tPar[2] * sin(tPar[6] * t * 360),
	}
end

function makeSineDisc(tPar, tSeed)
	local L, W, H = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], tPar[4] - tPar[5], tPar[4])
	local t, v = srandom(tSeed), srandom3(tSeed, 360)
	return {L * t * cos(v), H * sin(t * 360 * tPar[6]), W * t * sin(v),}
end

function makeSinePlane(tPar, tSeed)
	local s, t = srandom(tSeed), srandom(tSeed)
	return
	{
		tPar[2] * s * 2 - tPar[2],
		tPar[4] * (sin(s * 360 * tPar[6]) + sin(t * 360 * tPar[6]))/2,
		tPar[3] * t * 2 - tPar[3],
	}
end

function makeMoebius(tPar, tSeed)
	local L, W, h = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], -tPar[4], tPar[4])
	local v = srandom3(tSeed, 360)
	return {L * cos(v) + h * cos(v/2) * cos(v), h * sin(v/2), W * sin(v) + h * cos(v/2) * sin(v),}
end

function makeKlein(tPar, tSeed)
	local u, v = srandomSet(tSeed,360,180)
	return
	{
		cos(u) * (cos(u/2) * (sqrt(2) + cos(v)) + sin(u/2) * sin(v) * cos(v))	* tPar[2],
		(-sin(u/2) * (sqrt(2) + cos(v)) + cos(u/2) * sin(v) * cos(v))		* tPar[4],
		sin(u) * (cos(u/2) * (sqrt(2) + cos(v)) + sin(u/2) * sin(v) * cos(v))	* tPar[3],
	}
end

function makeKlein8(tPar, tSeed)
	local u, v = srandomSet(tSeed,360,360)
	return
	{
		(tPar[6] + cos(u/2) * sin(v) - sin(u/2) * sin(v*2)) * cos(u)	* tPar[2],
		(sin(u/2) * sin(v) + cos(u/2) * sin(v*2))			* tPar[3],
		(tPar[6] + cos(u/2) * sin(v) - sin(u/2) * sin(v*2)) * sin(u)	* tPar[4],
	}
end

function makeKuen(tPar, tSeed)
	local u, v = srandomSet(tSeed,180,360)
	return
	{
		2 * (cos(v) + rad(v) * sin(v)) * sin(u)/(1 + rad(v)^2 * sin(u)^2)	* tPar[2],
		(log(tan(u/2)) + 2 * cos(u)/(1 + rad(v)^2 * sin(u)^2))			* tPar[3],
		2 * (sin(v) - rad(v) * cos(v)) * sin(u)/(1 + rad(v)^2 * sin(u)^2)	* tPar[4],
	}
end

function makeBoy(tPar, tSeed)
	local u, v = srandom(tSeed,180) - 90, srandom(tSeed,180)
	return
	{
		(sqrt(2) * cos(v)^2 * cos(2 * u) + cos(u) * sin(2 * v)) / (2 - sqrt(2) * sin(3 * u) * sin(2 * v))	* tPar[2],
		(3 * cos(v)^2) / (2 - sqrt(2) * sin(3 * u) * sin(2 * v))						* tPar[3],
		(sqrt(2) * cos(v)^2 * sin(2 * u) - sin(u) * sin(2 * v)) / (2 - sqrt(2) * sin(3 * u) * sin(2 * v))	* tPar[4],
	}
end

function makeRectangle(tPar, tSeed)
	local L, W, l = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], -tPar[2], tPar[2])
	local w, h = srandomSet2(tSeed, -tPar[3], tPar[3], -tPar[4], tPar[4])
	local p, t = srandomSign(tSeed), srandom(tSeed)
	if (t < 1/2) then
		l = L * p
	else
		w = W * p
	end
	return {l, h, w,}
end

function makeEllipse(tPar, tSeed)
	local L, W, h, v = srandomSet2(tSeed, tPar[2] - tPar[5], tPar[2], tPar[3] - tPar[5], tPar[3], -tPar[4], tPar[4])
	local v = srandom3(tSeed, 360)
	return {L * cos(v), h, W * sin(v),}
end

function makeParabola(tPar, tSeed)
	local w, h, p = srandomSet2(tSeed, -tPar[3], tPar[3], -tPar[4], tPar[4])
	local p = srandomSign(tSeed)
	return
	{
		sqrt(4 * w * tPar[2]) * p + srandom3(tSeed, -tPar[5]/2, tPar[5]/2),
		h,
		w + srandom3(tSeed, -tPar[5]/2, tPar[5]/2),
	}
end

function makeHyperbola(tPar, tSeed)
	local h, v = srandom3(tSeed, -tPar[4], tPar[4]), srandom3(tSeed, 360)
	return
	{
		tPar[2]/cos(v) + srandom3(tSeed, -tPar[5]/2, tPar[5]/2),
		h,
		tPar[3] * tan(v) + srandom3(tSeed, -tPar[5]/2, tPar[5]/2),
	}
end

function makeHypotrochoid(tPar, tSeed)
	local v, o, u = srandomSet(tSeed,360,360,180)
	return
	{
		(tPar[2] - tPar[3]) * cos(v * tPar[6]) + tPar[5] * cos((tPar[2] - tPar[3])/tPar[3] * v * tPar[6])	+ tPar[4] * sin(u) * cos(o),
		0													+ tPar[4] * sin(u) * sin(o),
		(tPar[2] - tPar[3]) * sin(v * tPar[6]) - tPar[5] * sin((tPar[2] - tPar[3])/tPar[3] * v * tPar[6])	+ tPar[4] * cos(u),
	}
end

function makeEpitrochoid(tPar, tSeed)
	local v, o, u = srandomSet(tSeed,360,360,180)
	return
	{
		(tPar[2] + tPar[3]) * cos(v * tPar[6]) - tPar[5] * cos((tPar[2] + tPar[3])/tPar[3] * v * tPar[6])	+ tPar[4] * sin(u) * cos(o),
		0													+ tPar[4] * sin(u) * sin(o),
		(tPar[2] + tPar[3]) * sin(v * tPar[6]) - tPar[5] * sin((tPar[2] + tPar[3])/tPar[3] * v * tPar[6])	+ tPar[4] * cos(u),
	}
end


--------------------------------------------------------------------------------
-- Debug functions
--

function print_map_stats()
	local total = iStartPoints + iPoints + iSpheres + iCameras + iSquadrons + iAsteroids + iSalvage + iPebbles + iClouds + iDustClouds + iNebulas + iDirLights + iRvAsteroids + iRvSquadrons
	print("Level loaded: " .. levelDesc)
	print("Maxplayers: " .. maxPlayers)
	print
	(
		"\niStartPoints = " .. iStartPoints ..
		"\n     iPoints = " ..      iPoints ..
		"\n    iSpheres = " ..     iSpheres ..
		"\n    iCameras = " ..     iCameras ..
		"\n  iSquadrons = " ..   iSquadrons ..
		"\n  iAsteroids = " ..   iAsteroids ..
		"\n    iSalvage = " ..     iSalvage ..
		"\n    iPebbles = " ..     iPebbles ..
		"\n     iClouds = " ..      iClouds ..
		"\n iDustClouds = " ..  iDustClouds ..
		"\n    iNebulas = " ..     iNebulas ..
		"\n  iDirLights = " ..   iDirLights ..
		"\niRvAsteroids = " .. iRvAsteroids ..
		"\niRvSquadrons = " .. iRvSquadrons ..
		"\n       total = " ..        total
	)
end
